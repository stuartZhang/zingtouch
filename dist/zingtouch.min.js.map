{"version":3,"sources":["webpack://ZingTouch/webpack/universalModuleDefinition","webpack://ZingTouch/webpack/bootstrap","webpack://ZingTouch/./src/core/classes/Binder.js","webpack://ZingTouch/./src/core/util.js","webpack://ZingTouch/./src/gestures/Gesture.js","webpack://ZingTouch/./src/core/dispatcher.js","webpack://ZingTouch/./src/core/interpreter.js","webpack://ZingTouch/./src/core/arbiter.js","webpack://ZingTouch/./src/gestures/Pan.js","webpack://ZingTouch/./src/gestures/Distance.js","webpack://ZingTouch/./src/gestures/Rotate.js","webpack://ZingTouch/./src/gestures/Swipe.js","webpack://ZingTouch/./src/gestures/Tap.js","webpack://ZingTouch/./src/core/classes/Binding.js","webpack://ZingTouch/./src/core/classes/ZingEvent.js","webpack://ZingTouch/./src/core/classes/Input.js","webpack://ZingTouch/./src/core/classes/State.js","webpack://ZingTouch/./src/core/classes/Region.js","webpack://ZingTouch/./src/ZingTouch.js","webpack://ZingTouch/./src/core/main.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","classes_Binder","Binder","element","bindOnce","state","_this","this","_classCallCheck","keys","registeredGestures","forEach","handler","capture","addBinding","core_util","normalizeEvent","freeze","mousedown","touchstart","pointerdown","mousemove","touchmove","pointermove","mouseup","touchend","pointerup","isWithin","currentX","currentY","previousX","previousY","tolerance","Math","abs","distanceBetweenTwoPoints","x0","x1","y0","y1","hypot","getMidpoint","x","y","getAngle","originX","originY","projectionX","projectionY","atan2","getAngularDistance","start","end","getVelocity","startX","startY","startTime","endX","endY","endTime","getRightMostInput","inputs","rightMost","distance","Number","MIN_VALUE","input","initial","isInteger","isInside","target","clientLeft","clientWidth","clientTop","clientHeight","getPropagationPath","event","path","node","document","push","parentNode","getPathIndex","index","length","obj","setMSPreventDefault","style","removeMSPreventDefault","preventDefault","returnValue","gestures_Gesture","Gesture","Gesture_classCallCheck","type","id","every","core_dispatcher","binding","data","events","newEvent","CustomEvent","gesture","getId","detail","bubbles","cancelable","dispatchEvent","ZingTouch","unbind","getType","emitEvent","core_interpreter","bindings","evType","map","current","reduce","accumulator","core_arbiter","region","eventType","buttons","updateInputs","retrieveBindingsByInitialPos","toBeDispatched","gestures","endCount","getCurrentEventType","resetInputs","DEFAULT_INPUTS","DEFAULT_MIN_THRESHOLD","gestures_Pan","Pan","options","Pan_classCallCheck","_possibleConstructorReturn","_getPrototypeOf","numInputs","threshold","_this2","progress","getGestureProgress","active","lastEmitted","_this3","output","reachedThreshold","distanceFromOrigin","directionFromOrigin","currentDirection","change","packData","_this4","Distance_DEFAULT_MIN_THRESHOLD","gestures_Distance","Distance","Distance_classCallCheck","Distance_possibleConstructorReturn","Distance_getPrototypeOf","isValid","lastEmittedDistance","numActiveInputs","currentDistance","centerPoint","center","Rotate_DEFAULT_INPUTS","gestures_Rotate","Rotate","arguments","undefined","Rotate_classCallCheck","Rotate_possibleConstructorReturn","Rotate_getPrototypeOf","currentPivot","bRect","getBoundingClientRect","left","width","top","height","currentAngle","initialAngle","previousAngle","angle","distanceFromLast","Swipe_DEFAULT_INPUTS","DEFAULT_MAX_REST_TIME","DEFAULT_ESCAPE_VELOCITY","DEFAULT_TIME_DISTORTION","DEFAULT_MAX_PROGRESS_STACK","gestures_Swipe","Swipe","Swipe_classCallCheck","Swipe_possibleConstructorReturn","Swipe_getPrototypeOf","maxRestTime","escapeVelocity","timeDistortion","maxProgressStack","moves","time","Date","getTime","shift","currentMove","pop","lastMove","velocity","duration","DEFAULT_MIN_DELAY_MS","DEFAULT_MAX_DELAY_MS","Tap_DEFAULT_INPUTS","DEFAULT_MOVE_PX_TOLERANCE","gestures_Tap","Tap","Tap_classCallCheck","Tap_possibleConstructorReturn","Tap_getPrototypeOf","minDelay","maxDelay","previous","_ret","resetProgress","v","Tap_typeof","MAX_VALUE","interval","classes_Binding","Binding","Binding_classCallCheck","classes_ZingEvent","ZingEvent","touchIdentifier","eventObj","ZingEvent_classCallCheck","originalEvent","touches","changedTouches","Array","from","find","identifier","clientX","clientY","pageX","pageY","screenX","screenY","classes_Input","Input","Input_classCallCheck","currentEvent","classes_State","State","regionId","State_classCallCheck","numGestures","registerGesture","boundGesture","tagName","Error","indexOf","State_typeof","assignGestureId","addEventListener","filter","b","some","regionElement","pointerType","touch","update","pointerId","findInputById","setId","classes_Region","Region","Region_classCallCheck","PointerEvent","TouchEvent","e","unbound","retrieveBindingsByElement","removeEventListener","setType","registeredGesture","ZingTouch_ZingTouch","_regions","src_ZingTouch","__webpack_exports__"],"mappings":"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","file":"zingtouch.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ZingTouch\"] = factory();\n\telse\n\t\troot[\"ZingTouch\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n * @file Binder.js\r\n */\r\n\r\n/**\r\n * A chainable object that contains a single element to be bound upon.\r\n * Called from ZingTouch.bind(), and is used to chain over gesture callbacks.\r\n * @class\r\n */\r\nclass Binder {\r\n  /**\r\n   * Constructor function for the Binder class.\r\n   * @param {Element} element - The element to bind gestures to.\r\n   * @param {Boolean} bindOnce - Option to bind once and only emit\r\n   * the event once.\r\n   * @param {Object} state - The state of the Region that is being bound to.\r\n   * @return {Object} - Returns 'this' to be chained over and over again.\r\n   */\r\n  constructor(element, bindOnce, state) {\r\n    /**\r\n     * The element to bind gestures to.\r\n     * @type {Element}\r\n     */\r\n    this.element = element;\r\n\r\n    Object.keys(state.registeredGestures).forEach((key) => {\r\n      this[key] = (handler, capture) => {\r\n        state.addBinding(this.element, key, handler, capture, bindOnce);\r\n        return this;\r\n      };\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport default Binder;\r\n","/**\r\n * @file util.js\r\n * Various accessor and mutator functions to handle state and validation.\r\n */\r\n\r\n/**\r\n *  Contains generic helper functions\r\n * @type {Object}\r\n * @namespace util\r\n */\r\nlet util = {\r\n\r\n  /**\r\n   * Normalizes window events to be either of type start, move, or end.\r\n   * @param {String} type - The event type emitted by the browser\r\n   * @return {null|String} - The normalized event, or null if it is an\r\n   * event not predetermined.\r\n   */\r\n  normalizeEvent: Object.freeze({\r\n      mousedown:   'start',\r\n      touchstart:  'start',\r\n      pointerdown: 'start',\r\n\r\n      mousemove:   'move',\r\n      touchmove:   'move',\r\n      pointermove: 'move',\r\n\r\n      mouseup:   'end',\r\n      touchend:  'end',\r\n      pointerup: 'end',\r\n  }),\r\n  /* normalizeEvent*/\r\n\r\n  /**\r\n   * Determines if the current and previous coordinates are within or\r\n   * up to a certain tolerance.\r\n   * @param {Number} currentX - Current event's x coordinate\r\n   * @param {Number} currentY - Current event's y coordinate\r\n   * @param {Number} previousX - Previous event's x coordinate\r\n   * @param {Number} previousY - Previous event's y coordinate\r\n   * @param {Number} tolerance - The tolerance in pixel value.\r\n   * @return {boolean} - true if the current coordinates are\r\n   * within the tolerance, false otherwise\r\n   */\r\n  isWithin(currentX, currentY, previousX, previousY, tolerance) {\r\n    return ((Math.abs(currentY - previousY) <= tolerance) &&\r\n    (Math.abs(currentX - previousX) <= tolerance));\r\n  },\r\n  /* isWithin*/\r\n\r\n  /**\r\n   * Calculates the distance between two points.\r\n   * @param {Number} x0\r\n   * @param {Number} x1\r\n   * @param {Number} y0\r\n   * @param {Number} y1\r\n   * @return {number} The numerical value between two points\r\n   */\r\n  distanceBetweenTwoPoints(x0, x1, y0, y1) {\r\n    return Math.hypot(x1 - x0, y1 - y0);\r\n  },\r\n\r\n  /**\r\n   * Calculates the midpoint coordinates between two points.\r\n   * @param {Number} x0\r\n   * @param {Number} x1\r\n   * @param {Number} y0\r\n   * @param {Number} y1\r\n   * @return {Object} The coordinates of the midpoint.\r\n   */\r\n  getMidpoint(x0, x1, y0, y1) {\r\n    return {\r\n      x: ((x0 + x1) / 2),\r\n      y: ((y0 + y1) / 2),\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Calculates the angle between the projection and an origin point.\r\n   *   |                (projectionX,projectionY)\r\n   *   |             /°\r\n   *   |          /\r\n   *   |       /\r\n   *   |    / θ\r\n   *   | /__________\r\n   *   ° (originX, originY)\r\n   * @param {number} originX\r\n   * @param {number} originY\r\n   * @param {number} projectionX\r\n   * @param {number} projectionY\r\n   * @return {number} - Radians along the unit circle where the projection lies\r\n   */\r\n  getAngle(originX, originY, projectionX, projectionY) {\r\n    return Math.atan2(projectionY - originY, projectionX - originX);\r\n  },\r\n\r\n  /**\r\n   * Calculates the angular distance in radians between two angles along the\r\n   * unit circle\r\n   * @param {number} start - The starting point in radians\r\n   * @param {number} end - The ending point in radians\r\n   * @return {number} The number of radians between the starting point and\r\n   * ending point. \r\n   */\r\n  getAngularDistance(start, end) {\r\n    return end - start;\r\n  },\r\n\r\n  /**\r\n   * Calculates the velocity of pixel/milliseconds between two points\r\n   * @param {Number} startX\r\n   * @param {Number} startY\r\n   * @param {Number} startTime\r\n   * @param {Number} endX\r\n   * @param {Number} endY\r\n   * @param {Number} endTime\r\n   * @return {Number} velocity of px/time\r\n   */\r\n  getVelocity(startX, startY, startTime, endX, endY, endTime) {\r\n    let distance = this.distanceBetweenTwoPoints(startX, endX, startY, endY);\r\n    return (distance / (endTime - startTime));\r\n  },\r\n\r\n  /**\r\n   * Returns the farthest right input\r\n   * @param {Array} inputs\r\n   * @return {Object}\r\n   */\r\n  getRightMostInput(inputs) {\r\n    let rightMost = null;\r\n    let distance = Number.MIN_VALUE;\r\n    inputs.forEach((input) => {\r\n      if (input.initial.x > distance) {\r\n        rightMost = input;\r\n      }\r\n    });\r\n    return rightMost;\r\n  },\r\n\r\n  /**\r\n   * Determines is the value is an integer and not a floating point\r\n   * @param {Mixed} value\r\n   * @return {boolean}\r\n   */\r\n  isInteger(value) {\r\n    return (typeof value === 'number') && (value % 1 === 0);\r\n  },\r\n\r\n  /**\r\n   * Determines if the x,y position of the input is within then target.\r\n   * @param {Number} x -clientX\r\n   * @param {Number} y -clientY\r\n   * @param {Element} target\r\n   * @return {Boolean}\r\n   */\r\n  isInside(x, y, target) {\r\n    return ((x > target.clientLeft && x < target.clientLeft + target.clientWidth) &&\r\n            (y > target.clientTop  && y < target.clientTop  + target.clientHeight));\r\n  },\r\n  /**\r\n   * Polyfill for event.propagationPath\r\n   * @param {Event} event\r\n   * @return {Array}\r\n   */\r\n  getPropagationPath(event) {\r\n    if (event.path) {\r\n      return event.path;\r\n    } else {\r\n      let path = [];\r\n      let node = event.target;\r\n      while (node != document) {\r\n        path.push(node);\r\n        node = node.parentNode;\r\n      }\r\n\r\n      return path;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Retrieve the index inside the path array\r\n   * @param {Array} path\r\n   * @param {Element} element\r\n   * @return {Element}\r\n   */\r\n  getPathIndex(path, element) {\r\n    let index = path.length;\r\n\r\n    path.forEach((obj, i) => {\r\n      if (obj === element) {\r\n        index = i;\r\n      }\r\n    });\r\n\r\n    return index;\r\n  },\r\n\r\n  setMSPreventDefault(element) {\r\n    element.style['-ms-content-zooming'] = 'none';\r\n    element.style['touch-action'] = 'none';\r\n  },\r\n\r\n  removeMSPreventDefault(element) {\r\n    element.style['-ms-content-zooming'] = '';\r\n    element.style['touch-action'] = '';\r\n  },\r\n\r\n  preventDefault(event) {\r\n    if (event.preventDefault) {\r\n      event.preventDefault();\r\n    } else {\r\n      event.returnValue = false;\r\n    }\r\n  }\r\n};\r\n\r\nexport default util;\r\n","/**\r\n * @file Gesture.js\r\n * Contains the Gesture class\r\n */\r\n\r\nimport util from './../core/util.js';\r\n\r\n/**\r\n * The Gesture class that all gestures inherit from.\r\n */\r\nclass Gesture {\r\n  /**\r\n   * Constructor function for the Gesture class.\r\n   * @class Gesture\r\n   */\r\n  constructor() {\r\n    /**\r\n     * The generic string type of gesture ('expand'|'distance'|\r\n     *  'rotate'|'swipe'|'tap').\r\n     * @type {String}\r\n     */\r\n    this.type = null;\r\n\r\n    /**\r\n     * The unique identifier for each gesture determined at bind time by the\r\n     * state object. This allows for distinctions across instance variables of\r\n     * Gestures that are created on the fly (e.g. Tap-1, Tap-2, etc).\r\n     * @type {String|null}\r\n     */\r\n    this.id = null;\r\n  }\r\n\r\n  /**\r\n   * Set the type of the gesture to be called during an event\r\n   * @param {String} type - The unique identifier of the gesture being created.\r\n   */\r\n  setType(type) {\r\n    this.type = type;\r\n  }\r\n\r\n  /**\r\n   * getType() - Returns the generic type of the gesture\r\n   * @return {String} - The type of gesture\r\n   */\r\n  getType() {\r\n    return this.type;\r\n  }\r\n\r\n  /**\r\n   * Set the id of the gesture to be called during an event\r\n   * @param {String} id - The unique identifier of the gesture being created.\r\n   */\r\n  setId(id) {\r\n    this.id = id;\r\n  }\r\n\r\n  /**\r\n   * Return the id of the event. If the id does not exist, return the type.\r\n   * @return {String}\r\n   */\r\n  getId() {\r\n    return (this.id !== null) ? this.id : this.type;\r\n  }\r\n\r\n  /**\r\n   * Updates internal properties with new ones, only if the properties exist.\r\n   * @param {Object} object\r\n   */\r\n  update(object) {\r\n    Object.keys(object).forEach( key => {\r\n      this[key] = object[key];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * start() - Event hook for the start of a gesture\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n\t * @param {Object} state - The state object of the current region.\r\n\t * @param {Element} element - The element associated to the binding.\r\n   * @return {null|Object}  - Default of null\r\n   */\r\n  start(inputs, state, element) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * move() - Event hook for the move of a gesture\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @param {Object} state - The state object of the current region.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {null|Object} - Default of null\r\n   */\r\n  move(inputs, state, element) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * end() - Event hook for the move of a gesture\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @return {null|Object}  - Default of null\r\n   */\r\n  end(inputs) {\r\n    return null;\r\n  }\r\n\r\n\t/**\r\n\t* isValid() - Pre-checks to ensure the invariants of a gesture are satisfied.\r\n\t* @param {Array} inputs - The array of Inputs on the screen\r\n\t* @param {Object} state - The state object of the current region.\r\n\t* @param {Element} element - The element associated to the binding.\r\n\t* @return {boolean} - If the gesture is valid\r\n\t*/\r\n\tisValid(inputs, state, element) {\r\n    return inputs.every( input => {\r\n        return util.isInside(input.initial.x, input.initial.y, element);\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport default Gesture;\r\n","/**\r\n * @file dispatcher.js\r\n * Contains logic for the dispatcher\r\n */\r\n\r\n/**\r\n * Emits data at the target element if available, and bubbles up from\r\n * the target to the parent until the document has been reached.\r\n * Called from the arbiter.\r\n * @param {Binding} binding - An object of type Binding\r\n * @param {Object} data - The metadata computed by the gesture being emitted.\r\n * @param {Array} events - An array of ZingEvents\r\n *  corresponding to the inputs on the screen.\r\n */\r\nfunction dispatcher(binding, data, events) {\r\n  data.events = events;\r\n\r\n  const newEvent = new CustomEvent(binding.gesture.getId(), {\r\n    detail: data,\r\n    bubbles: true,\r\n    cancelable: true,\r\n  });\r\n  emitEvent(binding.element, newEvent, binding);\r\n}\r\n\r\n/**\r\n * Emits the new event. Unbinds the event if the event was registered\r\n * at bindOnce.\r\n * @param {Element} target - Element object to emit the event to.\r\n * @param {Event} event - The CustomEvent to emit.\r\n * @param {Binding} binding - An object of type Binding\r\n */\r\nfunction emitEvent(target, event, binding) {\r\n  target.dispatchEvent(event);\r\n  if (binding.bindOnce) {\r\n    ZingTouch.unbind(binding.element, binding.gesture.getType());\r\n  }\r\n}\r\n\r\nexport default dispatcher;\r\n","/**\r\n * @file interpreter.js\r\n * Contains logic for the interpreter\r\n */\r\n\r\nimport util from './util.js';\r\n\r\n/**\r\n * Receives an event and an array of Bindings (element -> gesture handler)\r\n * to determine what event will be emitted. Called from the arbiter.\r\n * @param {Array} bindings - An array containing Binding objects\r\n * that associate the element to an event handler.\r\n * @param {Object} event - The event emitted from the window.\r\n * @param {Object} state - The state object of the current listener.\r\n * @return {Object | null} - Returns an object containing a binding and\r\n * metadata, or null if a gesture will not be emitted.\r\n */\r\nfunction interpreter(bindings, event, state) {\r\n  const evType = util.normalizeEvent[ event.type ];\r\n  const events = state.inputs.map( input => input.current );\r\n\r\n  const candidates = bindings.reduce( (accumulator, binding) => {\r\n    const data = binding.gesture[evType](state.inputs, state, binding.element);\r\n    if (data) accumulator.push({ binding, data, events });\r\n    return accumulator;\r\n  }, []);\r\n\r\n  return candidates;\r\n}\r\n\r\nexport default interpreter;\r\n","/**\r\n * @file arbiter.js\r\n * Contains logic for the dispatcher\r\n */\r\n\r\nimport dispatcher from './dispatcher.js';\r\nimport interpreter from './interpreter.js';\r\nimport util from './util.js';\r\n\r\n/**\r\n * Function that handles event flow, negotiating with the interpreter,\r\n * and dispatcher.\r\n * 1. Receiving all touch events in the window.\r\n * 2. Determining which gestures are linked to the target element.\r\n * 3. Negotiating with the Interpreter what event should occur.\r\n * 4. Sending events to the dispatcher to emit events to the target.\r\n * @param {Event} event - The event emitted from the window object.\r\n * @param {Object} region - The region object of the current listener.\r\n */\r\nfunction arbiter(event, region) {\r\n  const state = region.state;\r\n  const eventType = util.normalizeEvent[ event.type ];\r\n\r\n  /*\r\n   Return if a gesture is not in progress and won't be. Also catches the case\r\n   where a previous event is in a partial state (2 finger pan, waits for both\r\n   inputs to reach touchend)\r\n   */\r\n  if (state.inputs.length === 0 && eventType !== 'start') {\r\n    return;\r\n  }\r\n\r\n  /*\r\n   Check for 'stale' or events that lost focus\r\n   (e.g. a pan goes off screen/off region.)\r\n   Does not affect mobile devices.\r\n   */\r\n  if (typeof event.buttons !== 'undefined' &&\r\n    eventType !== 'end' &&\r\n    event.buttons === 0) {\r\n    state.resetInputs();\r\n    return;\r\n  }\r\n\r\n  // Update the state with the new events. If the event is stopped, return;\r\n  if (!state.updateInputs(event, region.element)) {\r\n    return;\r\n  }\r\n\r\n  // Retrieve the initial target from any one of the inputs\r\n  const bindings = state.retrieveBindingsByInitialPos();\r\n  if (bindings.length > 0) {\r\n    if (region.preventDefault) {\r\n      util.setMSPreventDefault(region.element);\r\n      util.preventDefault(event);\r\n    } else {\r\n      util.removeMSPreventDefault(region.element);\r\n    }\r\n\r\n    const toBeDispatched = {};\r\n    const gestures = interpreter(bindings, event, state);\r\n\r\n    /* Determine the deepest path index to emit the event\r\n     from, to avoid duplicate events being fired. */\r\n\r\n    const path = util.getPropagationPath(event);\r\n    gestures.forEach((gesture) => {\r\n      const id = gesture.binding.gesture.getId();\r\n      if (toBeDispatched[id]) {\r\n        if (util.getPathIndex(path, gesture.binding.element) <\r\n          util.getPathIndex(path, toBeDispatched[id].binding.element)) {\r\n          toBeDispatched[id] = gesture;\r\n        }\r\n      } else {\r\n        toBeDispatched[id] = gesture;\r\n      }\r\n    });\r\n\r\n    Object.keys(toBeDispatched).forEach((index) => {\r\n      const gesture = toBeDispatched[index];\r\n      dispatcher(gesture.binding, gesture.data, gesture.events);\r\n    });\r\n  }\r\n\r\n  let endCount = 0;\r\n  state.inputs.forEach((input) => {\r\n    if (input.getCurrentEventType() === 'end') {\r\n      endCount++;\r\n    }\r\n  });\r\n\r\n  if (endCount === state.inputs.length) {\r\n    state.resetInputs();\r\n  }\r\n}\r\n\r\nexport default arbiter;\r\n","/**\r\n * @file Pan.js\r\n * Contains the Pan class\r\n */\r\n\r\nimport Gesture from './Gesture.js';\r\nimport util from './../core/util.js';\r\n\r\nconst DEFAULT_INPUTS = 1;\r\nconst DEFAULT_MIN_THRESHOLD = 1;\r\n\r\n/**\r\n * A Pan is defined as a normal movement in any direction on a screen.\r\n * Pan gestures do not track start events and can interact with distance gestures\r\n * @class Pan\r\n */\r\nclass Pan extends Gesture {\r\n  /**\r\n   * Constructor function for the Pan class.\r\n   * @param {Object} [options] - The options object.\r\n   * @param {Number} [options.numInputs=1] - Number of inputs for the\r\n   *  Pan gesture.\r\n   * @param {Number} [options.threshold=1] - The minimum number of\r\n   * pixels the input has to move to trigger this gesture.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /**\r\n     * The type of the Gesture.\r\n     * @type {String}\r\n     */\r\n    this.type = 'pan';\r\n\r\n    /**\r\n     * The number of inputs to trigger a Pan can be variable,\r\n     * and the maximum number being a factor of the browser.\r\n     * @type {Number}\r\n     */\r\n    this.numInputs = (options && options.numInputs) ?\r\n      options.numInputs : DEFAULT_INPUTS;\r\n\r\n    /**\r\n     * The minimum amount in pixels the pan must move until it is fired.\r\n     * @type {Number}\r\n     */\r\n    this.threshold = (options && options.threshold) ?\r\n      options.threshold : DEFAULT_MIN_THRESHOLD;\r\n  }\r\n\r\n  /**\r\n   * Event hook for the start of a gesture. Marks each input as active,\r\n   * so it can invalidate any end events.\r\n   * @param {Array} inputs\r\n   */\r\n  start(inputs) {\r\n    inputs.forEach((input) => {\r\n      const progress = input.getGestureProgress(this.getId());\r\n      progress.active = true;\r\n      progress.lastEmitted = {\r\n        x: input.current.x,\r\n        y: input.current.y,\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * move() - Event hook for the move of a gesture.\r\n   * Fired whenever the input length is met, and keeps a boolean flag that\r\n   * the gesture has fired at least once.\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @param {Object} state - The state object of the current region.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {Object} - Returns the distance in pixels between the two inputs.\r\n   */\r\n  move(inputs, state, element) {\r\n    if (this.numInputs !== inputs.length) return null;\r\n\r\n    const output = {\r\n      data: [],\r\n    };\r\n\r\n    inputs.forEach( (input, index) => {\r\n      const progress = input.getGestureProgress(this.getId());\r\n      const distanceFromLastEmit = util.distanceBetweenTwoPoints(\r\n        progress.lastEmitted.x,\r\n        progress.lastEmitted.y,\r\n        input.current.x,\r\n        input.current.y\r\n      );\r\n      const reachedThreshold = distanceFromLastEmit >= this.threshold;\r\n\r\n      if (progress.active && reachedThreshold) {\r\n        output.data[index] = packData( input, progress );\r\n        progress.lastEmitted.x = input.current.x;\r\n        progress.lastEmitted.y = input.current.y;\r\n      }\r\n    });\r\n\r\n    return output;\r\n\r\n    function packData( input, progress ) {\r\n      const distanceFromOrigin = util.distanceBetweenTwoPoints(\r\n        input.initial.x,\r\n        input.current.x,\r\n        input.initial.y,\r\n        input.current.y\r\n      );\r\n      const directionFromOrigin = util.getAngle(\r\n        input.initial.x,\r\n        input.initial.y,\r\n        input.current.x,\r\n        input.current.y\r\n      );\r\n      const currentDirection = util.getAngle(\r\n        progress.lastEmitted.x,\r\n        progress.lastEmitted.y,\r\n        input.current.x,\r\n        input.current.y\r\n      );\r\n      const change = {\r\n        x: input.current.x - progress.lastEmitted.x,\r\n        y: input.current.y - progress.lastEmitted.y,\r\n      };\r\n\r\n      return {\r\n        distanceFromOrigin,\r\n        directionFromOrigin,\r\n        currentDirection,\r\n        change,\r\n      };\r\n    }\r\n  }\r\n\r\n  /* move*/\r\n\r\n  /**\r\n   * end() - Event hook for the end of a gesture. If the gesture has at least\r\n   * fired once, then it ends on the first end event such that any remaining\r\n   * inputs will not trigger the event until all inputs have reached the\r\n   * touchend event. Any touchend->touchstart events that occur before all\r\n   * inputs are fully off the screen should not fire.\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @return {null} - null if the gesture is not to be emitted,\r\n   *  Object with information otherwise.\r\n   */\r\n  end(inputs) {\r\n    inputs.forEach((input) => {\r\n      const progress = input.getGestureProgress(this.getId());\r\n      progress.active = false;\r\n    });\r\n    return null;\r\n  }\r\n\r\n  /* end*/\r\n}\r\n\r\nexport default Pan;\r\n","/**\r\n * @file Distance.js\r\n * Contains the abstract Distance class\r\n */\r\n\r\nimport Gesture from './Gesture.js';\r\nimport util from './../core/util.js';\r\n\r\nconst DEFAULT_INPUTS = 2;\r\nconst DEFAULT_MIN_THRESHOLD = 1;\r\n\r\n/**\r\n * A Distance is defined as two inputs moving either together or apart.\r\n * @class Distance\r\n */\r\nclass Distance extends Gesture {\r\n  /**\r\n   * Constructor function for the Distance class.\r\n   * @param {Object} options\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /**\r\n     * The type of the Gesture.\r\n     * @type {String}\r\n     */\r\n    this.type = 'distance';\r\n\r\n    /**\r\n     * The minimum amount in pixels the inputs must move until it is fired.\r\n     * @type {Number}\r\n     */\r\n    this.threshold = (options && options.threshold) ?\r\n      options.threshold : DEFAULT_MIN_THRESHOLD;\r\n  }\r\n\r\n  /**\r\n   * Event hook for the start of a gesture. Initialized the lastEmitted\r\n   * gesture and stores it in the first input for reference events.\r\n   * @param {Array} inputs\r\n   */\r\n  start(inputs, state, element) {\r\n    if(!this.isValid(inputs, state, element)) {\r\n      return null;\r\n    }\r\n    if (inputs.length === DEFAULT_INPUTS) {\r\n      // Store the progress in the first input.\r\n      const progress = inputs[0].getGestureProgress(this.getId());\r\n      progress.lastEmittedDistance = util.distanceBetweenTwoPoints(\r\n        inputs[0].current.x,\r\n        inputs[1].current.x,\r\n        inputs[0].current.y,\r\n        inputs[1].current.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Event hook for the move of a gesture.\r\n   *  Determines if the two points are moved in the expected direction relative\r\n   *  to the current distance and the last distance.\r\n   * @param {Array} inputs - The array of Inputs on the screen.\r\n   * @param {Object} state - The state object of the current region.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {Object | null} - Returns the distance in pixels between two inputs\r\n   */\r\n  move(inputs, state, element) {\r\n    if (state.numActiveInputs() === DEFAULT_INPUTS) {\r\n      const currentDistance = util.distanceBetweenTwoPoints(\r\n        inputs[0].current.x,\r\n        inputs[1].current.x,\r\n        inputs[0].current.y,\r\n        inputs[1].current.y);\r\n      const centerPoint = util.getMidpoint(\r\n        inputs[0].current.x,\r\n        inputs[1].current.x,\r\n        inputs[0].current.y,\r\n        inputs[1].current.y);\r\n\r\n      // Progress is stored in the first input.\r\n      const progress = inputs[0].getGestureProgress(this.getId());\r\n      const change = currentDistance - progress.lastEmittedDistance;\r\n\r\n      if (Math.abs(change) >= this.threshold) {\r\n        progress.lastEmittedDistance = currentDistance;\r\n        return {\r\n          distance: currentDistance,\r\n          center: centerPoint,\r\n          change,\r\n        };\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexport default Distance;\r\n","/**\r\n * @file Rotate.js\r\n * Contains the Rotate class\r\n */\r\n\r\nimport Gesture from './Gesture.js';\r\nimport util from './../core/util.js';\r\n\r\nconst DEFAULT_INPUTS = 2;\r\n\r\n/**\r\n * A Rotate is defined as two inputs moving about a circle,\r\n * maintaining a relatively equal radius.\r\n * @class Rotate\r\n */\r\nclass Rotate extends Gesture {\r\n  /**\r\n   * Constructor function for the Rotate class.\r\n   */\r\n  constructor(options = {}) {\r\n    super();\r\n\r\n    /**\r\n     * The type of the Gesture.\r\n     * @type {String}\r\n     */\r\n    this.type = 'rotate';\r\n\r\n    /**\r\n     * The number of touches required to emit Rotate events.\r\n     * @type {Number}\r\n     */\r\n    this.numInputs = options.numInputs || DEFAULT_INPUTS;\r\n  }\r\n\r\n  /**\r\n   * move() - Event hook for the move of a gesture. Obtains the midpoint of two\r\n   * the two inputs and calculates the projection of the right most input along\r\n   * a unit circle to obtain an angle. This angle is compared to the previously\r\n   * calculated angle to output the change of distance, and is compared to the\r\n   * initial angle to output the distance from the initial angle to the current\r\n   * angle.\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @param {Object} state - The state object of the current listener.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {null} - null if this event did not occur\r\n   * @return {Object} obj.angle - The current angle along the unit circle\r\n   * @return {Object} obj.distanceFromOrigin - The angular distance travelled\r\n   * from the initial right most point.\r\n   * @return {Object} obj.distanceFromLast - The change of angle between the\r\n   * last position and the current position.\r\n   */\r\n  move(inputs, state, element) {\r\n    const numActiveInputs = state.numActiveInputs();\r\n    if (this.numInputs !== numActiveInputs) return null;\r\n\r\n    let currentPivot, initialPivot;\r\n    let input;\r\n    if (numActiveInputs === 1) {\r\n      const bRect = element.getBoundingClientRect();\r\n      currentPivot = {\r\n        x: bRect.left + bRect.width / 2,\r\n        y: bRect.top + bRect.height / 2,\r\n      };\r\n      initialPivot = currentPivot;\r\n      input = inputs[0];\r\n    } else {\r\n      currentPivot = util.getMidpoint(\r\n        inputs[0].current.x,\r\n        inputs[1].current.x,\r\n        inputs[0].current.y,\r\n        inputs[1].current.y);\r\n      input = util.getRightMostInput(inputs);\r\n    }\r\n\r\n    // Translate the current pivot point.\r\n    const currentAngle = util.getAngle(\r\n      currentPivot.x, \r\n      currentPivot.y,\r\n      input.current.x,\r\n      input.current.y);\r\n\r\n    const progress = input.getGestureProgress(this.getId());\r\n    if (!progress.initialAngle) {\r\n      progress.initialAngle = progress.previousAngle = currentAngle;\r\n      progress.distance = progress.change = 0;\r\n    } else {\r\n      progress.change = util.getAngularDistance(\r\n        progress.previousAngle,\r\n        currentAngle);\r\n      progress.distance = progress.distance + progress.change;\r\n    }\r\n\r\n    progress.previousAngle = currentAngle;\r\n\r\n    return {\r\n      angle: currentAngle,\r\n      distanceFromOrigin: progress.distance,\r\n      distanceFromLast: progress.change,\r\n    };\r\n  }\r\n\r\n  /* move*/\r\n}\r\n\r\nexport default Rotate;\r\n","/**\r\n * @file Swipe.js\r\n * Contains the Swipe class\r\n */\r\n\r\nimport Gesture from './Gesture.js';\r\nimport util from './../core/util.js';\r\n\r\nconst DEFAULT_INPUTS = 1;\r\nconst DEFAULT_MAX_REST_TIME = 100;\r\nconst DEFAULT_ESCAPE_VELOCITY = 0.2;\r\nconst DEFAULT_TIME_DISTORTION = 100;\r\nconst DEFAULT_MAX_PROGRESS_STACK = 10;\r\n\r\n/**\r\n * A swipe is defined as input(s) moving in the same direction in an relatively\r\n * increasing velocity and leaving the screen at some point before it drops\r\n * below it's escape velocity.\r\n * @class Swipe\r\n */\r\nclass Swipe extends Gesture {\r\n\r\n  /**\r\n   * Constructor function for the Swipe class.\r\n   * @param {Object} [options] - The options object.\r\n   * @param {Number} [options.numInputs] - The number of inputs to trigger a\r\n   * Swipe can be variable, and the maximum number being a factor of the browser\r\n   *  move and current move events.\r\n   * @param {Number} [options.maxRestTime] - The maximum resting time a point\r\n   *  has between it's last\r\n   * @param {Number} [options.escapeVelocity] - The minimum velocity the input\r\n   *  has to be at to emit a swipe.\r\n   * @param {Number} [options.timeDistortion] - (EXPERIMENTAL) A value of time\r\n   *  in milliseconds to distort between events.\r\n   * @param {Number} [options.maxProgressStack] - (EXPERIMENTAL)The maximum\r\n   *  amount of move events to keep\r\n   * track of for a swipe.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n    /**\r\n     * The type of the Gesture\r\n     * @type {String}\r\n     */\r\n    this.type = 'swipe';\r\n\r\n    /**\r\n     * The number of inputs to trigger a Swipe can be variable,\r\n     * and the maximum number being a factor of the browser.\r\n     * @type {Number}\r\n     */\r\n    this.numInputs = (options && options.numInputs) ?\r\n      options.numInputs : DEFAULT_INPUTS;\r\n\r\n    /**\r\n     * The maximum resting time a point has between it's last move and\r\n     * current move events.\r\n     * @type {Number}\r\n     */\r\n    this.maxRestTime = (options && options.maxRestTime) ?\r\n      options.maxRestTime : DEFAULT_MAX_REST_TIME;\r\n\r\n    /**\r\n     * The minimum velocity the input has to be at to emit a swipe.\r\n     * This is useful for determining the difference between\r\n     * a swipe and a pan gesture.\r\n     * @type {number}\r\n     */\r\n    this.escapeVelocity = (options && options.escapeVelocity) ?\r\n      options.escapeVelocity : DEFAULT_ESCAPE_VELOCITY;\r\n\r\n    /**\r\n     * (EXPERIMENTAL) A value of time in milliseconds to distort between events.\r\n     * Browsers do not accurately measure time with the Date constructor in\r\n     * milliseconds, so consecutive events sometimes display the same timestamp\r\n     * but different x/y coordinates. This will distort a previous time\r\n     * in such cases by the timeDistortion's value.\r\n     * @type {number}\r\n     */\r\n    this.timeDistortion = (options && options.timeDistortion) ?\r\n      options.timeDistortion : DEFAULT_TIME_DISTORTION;\r\n\r\n    /**\r\n     * (EXPERIMENTAL) The maximum amount of move events to keep track of for a\r\n     * swipe. This helps give a more accurate estimate of the user's velocity.\r\n     * @type {number}\r\n     */\r\n    this.maxProgressStack = (options && options.maxProgressStack) ?\r\n      options.maxProgressStack : DEFAULT_MAX_PROGRESS_STACK;\r\n  }\r\n\r\n  /**\r\n   * Event hook for the move of a gesture. Captures an input's x/y coordinates\r\n   * and the time of it's event on a stack.\r\n   * @param {Array} inputs - The array of Inputs on the screen.\r\n   * @param {Object} state - The state object of the current region.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {null} - Swipe does not emit from a move.\r\n   */\r\n  move(inputs, state, element) {\r\n    if (this.numInputs === inputs.length) {\r\n      for (let i = 0; i < inputs.length; i++) {\r\n        let progress = inputs[i].getGestureProgress(this.getId());\r\n        if (!progress.moves) {\r\n          progress.moves = [];\r\n        }\r\n\r\n        progress.moves.push({\r\n          time: new Date().getTime(),\r\n          x: inputs[i].current.x,\r\n          y: inputs[i].current.y,\r\n        });\r\n\r\n        if (progress.length > this.maxProgressStack) {\r\n          progress.moves.shift();\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /* move*/\r\n\r\n  /**\r\n   * Determines if the input's history validates a swipe motion.\r\n   * Determines if it did not come to a complete stop (maxRestTime), and if it\r\n   * had enough of a velocity to be considered (ESCAPE_VELOCITY).\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @return {null|Object} - null if the gesture is not to be emitted,\r\n   *  Object with information otherwise.\r\n   */\r\n  end(inputs) {\r\n    if (this.numInputs === inputs.length) {\r\n      let output = {\r\n        data: [],\r\n      };\r\n\r\n      for (var i = 0; i < inputs.length; i++) {\r\n        // Determine if all input events are on the 'end' event.\r\n        if (inputs[i].current.type !== 'end') {\r\n          return;\r\n        }\r\n\r\n        let progress = inputs[i].getGestureProgress(this.getId());\r\n        if (progress.moves && progress.moves.length > 2) {\r\n          // CHECK : Return if the input has not moved in maxRestTime ms.\r\n\r\n          let currentMove = progress.moves.pop();\r\n          if ((new Date().getTime()) - currentMove.time > this.maxRestTime) {\r\n            return null;\r\n          }\r\n\r\n          let lastMove;\r\n          let index = progress.moves.length - 1;\r\n\r\n          /* Date is unreliable, so we retrieve the last move event where\r\n           the time is not the same. */\r\n          while (index !== -1) {\r\n            if (progress.moves[index].time !== currentMove.time) {\r\n              lastMove = progress.moves[index];\r\n              break;\r\n            }\r\n\r\n            index--;\r\n          }\r\n\r\n          /* If the date is REALLY unreliable, we apply a time distortion\r\n           to the last event.\r\n           */\r\n          if (!lastMove) {\r\n            lastMove = progress.moves.pop();\r\n            lastMove.time += this.timeDistortion;\r\n          }\r\n\r\n          var velocity = util.getVelocity(lastMove.x, lastMove.y, lastMove.time,\r\n            currentMove.x, currentMove.y, currentMove.time);\r\n\r\n          output.data[i] = {\r\n            velocity: velocity,\r\n            distance: util.distanceBetweenTwoPoints(lastMove.x, currentMove.x, lastMove.y, currentMove.y),\r\n            duration:  currentMove.time - lastMove.time,\r\n            currentDirection: util.getAngle(\r\n              lastMove.x,\r\n              lastMove.y,\r\n              currentMove.x,\r\n              currentMove.y),\r\n          };\r\n        }\r\n      }\r\n\r\n      for (var i = 0; i < output.data.length; i++) {\r\n        if (velocity < this.escapeVelocity) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      if (output.data.length > 0) {\r\n        return output;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /* end*/\r\n}\r\n\r\nexport default Swipe;\r\n","/**\r\n * @file Tap.js\r\n * Contains the Tap class\r\n */\r\n\r\nimport Gesture from './Gesture.js';\r\nimport util from './../core/util.js';\r\n\r\nconst DEFAULT_MIN_DELAY_MS = 0;\r\nconst DEFAULT_MAX_DELAY_MS = 300;\r\nconst DEFAULT_INPUTS = 1;\r\nconst DEFAULT_MOVE_PX_TOLERANCE = 10;\r\n\r\n/**\r\n * A Tap is defined as a touchstart to touchend event in quick succession.\r\n * @class Tap\r\n */\r\nclass Tap extends Gesture {\r\n  /**\r\n   * Constructor function for the Tap class.\r\n   * @param {Object} [options] - The options object.\r\n   * @param {Number} [options.minDelay=0] - The minimum delay between a\r\n   * touchstart and touchend can be configured in milliseconds.\r\n   * @param {Number} [options.maxDelay=300] - The maximum delay between a\r\n   * touchstart and touchend can be configured in milliseconds.\r\n   * @param {Number} [options.numInputs=1] - Number of inputs for Tap gesture.\r\n   * @param {Number} [options.tolerance=10] - The tolerance in pixels\r\n   *  a user can move.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /**\r\n     * The type of the Gesture.\r\n     * @type {String}\r\n     */\r\n    this.type = 'tap';\r\n\r\n    /**\r\n     * The minimum amount between a touchstart and a touchend can be configured\r\n     * in milliseconds. The minimum delay starts to count down when the expected\r\n     * number of inputs are on the screen, and ends when ALL inputs are off the\r\n     * screen.\r\n     * @type {Number}\r\n     */\r\n    this.minDelay = (options && options.minDelay) ?\r\n      options.minDelay : DEFAULT_MIN_DELAY_MS;\r\n\r\n    /**\r\n     * The maximum delay between a touchstart and touchend can be configured in\r\n     * milliseconds. The maximum delay starts to count down when the expected\r\n     * number of inputs are on the screen, and ends when ALL inputs are off the\r\n     * screen.\r\n     * @type {Number}\r\n     */\r\n    this.maxDelay = (options && options.maxDelay) ?\r\n      options.maxDelay : DEFAULT_MAX_DELAY_MS;\r\n\r\n    /**\r\n     * The number of inputs to trigger a Tap can be variable,\r\n     * and the maximum number being a factor of the browser.\r\n     * @type {Number}\r\n     */\r\n    this.numInputs = (options && options.numInputs) ?\r\n      options.numInputs : DEFAULT_INPUTS;\r\n\r\n    /**\r\n     * A move tolerance in pixels allows some slop between a user's start to end\r\n     * events. This allows the Tap gesture to be triggered more easily.\r\n     * @type {number}\r\n     */\r\n    this.tolerance = (options && options.tolerance) ?\r\n      options.tolerance : DEFAULT_MOVE_PX_TOLERANCE;\r\n  }\r\n\r\n  /* constructor*/\r\n\r\n  /**\r\n   * Event hook for the start of a gesture. Keeps track of when the inputs\r\n   * trigger the start event.\r\n   * @param {Array} inputs - The array of Inputs on the screen.\r\n   * @return {null} - Tap does not trigger on a start event.\r\n   */\r\n  start(inputs) {\r\n    if (inputs.length === this.numInputs) {\r\n      inputs.forEach((input) => {\r\n        let progress = input.getGestureProgress(this.getId());\r\n        progress.start = new Date().getTime();\r\n      });\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /* start*/\r\n\r\n  /**\r\n   * Event hook for the move of a gesture. The Tap event reaches here if the\r\n   * user starts to move their input before an 'end' event is reached.\r\n   * @param {Array} inputs - The array of Inputs on the screen.\r\n   * @param {Object} state - The state object of the current region.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {null} - Tap does not trigger on a move event.\r\n   */\r\n  move(inputs, state, element) {\r\n    for (let i = 0; i < inputs.length; i++) {\r\n      if (inputs[i].getCurrentEventType() === 'move') {\r\n        let current = inputs[i].current;\r\n        let previous = inputs[i].previous;\r\n        if (!util.isWithin(\r\n            current.x,\r\n            current.y,\r\n            previous.x,\r\n            previous.y,\r\n            this.tolerance)) {\r\n          let type = this.type;\r\n          inputs.forEach(function(input) {\r\n            input.resetProgress(type);\r\n          });\r\n\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /* move*/\r\n\r\n  /**\r\n   * Event hook for the end of a gesture.\r\n   * Determines if this the tap event can be fired if the delay and tolerance\r\n   * constraints are met. Also waits for all of the inputs to be off the screen\r\n   * before determining if the gesture is triggered.\r\n   * @param {Array} inputs - The array of Inputs on the screen.\r\n   * @return {null|Object} - null if the gesture is not to be emitted,\r\n   * Object with information otherwise. Returns the interval time between start\r\n   * and end events.\r\n   */\r\n  end(inputs) {\r\n    if (inputs.length !== this.numInputs) {\r\n      return null;\r\n    }\r\n\r\n    let startTime = Number.MAX_VALUE;\r\n    for (let i = 0; i < inputs.length; i++) {\r\n      if (inputs[i].getCurrentEventType() !== 'end') {\r\n        return null;\r\n      }\r\n\r\n      let progress = inputs[i].getGestureProgress(this.getId());\r\n      if (!progress.start) {\r\n        return null;\r\n      }\r\n\r\n      // Find the most recent input's startTime\r\n      if (progress.start < startTime) {\r\n        startTime = progress.start;\r\n      }\r\n    }\r\n\r\n    let interval = new Date().getTime() - startTime;\r\n    if ((this.minDelay <= interval) && (this.maxDelay >= interval)) {\r\n      return {\r\n        interval: interval,\r\n      };\r\n    } else {\r\n      let type = this.type;\r\n      inputs.forEach(function(input) {\r\n        input.resetProgress(type);\r\n      });\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /* end*/\r\n}\r\n\r\nexport default Tap;\r\n","/**\r\n * @file Binding.js\r\n */\r\n\r\n/**\r\n * Responsible for creating a binding between an element and a gesture.\r\n * @class Binding\r\n */\r\nclass Binding {\r\n  /**\r\n   * Constructor function for the Binding class.\r\n   * @param {Element} element - The element to associate the gesture to.\r\n   * @param {Gesture} gesture - A instance of the Gesture type.\r\n   * @param {Function} handler - The function handler to execute when a\r\n   * gesture is recognized\r\n   * on the associated element.\r\n   * @param {Boolean} [capture=false] - A boolean signifying if the event is\r\n   * to be emitted during\r\n   * the capture or bubble phase.\r\n   * @param {Boolean} [bindOnce=false] - A boolean flag\r\n   * used for the bindOnce syntax.\r\n   */\r\n  constructor(element, gesture, handler, capture, bindOnce) {\r\n    /**\r\n     * The element to associate the gesture to.\r\n     * @type {Element}\r\n     */\r\n    this.element = element;\r\n    /**\r\n     * A instance of the Gesture type.\r\n     * @type {Gesture}\r\n     */\r\n    this.gesture = gesture;\r\n    /**\r\n     * The function handler to execute when a gesture is\r\n     * recognized on the associated element.\r\n     * @type {Function}\r\n     */\r\n    this.handler = handler;\r\n\r\n    /**\r\n     * A boolean signifying if the event is to be\r\n     * emitted during the capture or bubble phase.\r\n     * @type {Boolean}\r\n     */\r\n    this.capture = (typeof capture !== 'undefined') ? capture : false;\r\n\r\n    /**\r\n     * A boolean flag used for the bindOnce syntax.\r\n     * @type {Boolean}\r\n     */\r\n    this.bindOnce = (typeof bindOnce !== 'undefined') ? bindOnce : false;\r\n  }\r\n\r\n}\r\n\r\nexport default Binding;\r\n","/**\r\n * @file ZingEvent.js\r\n * Contains logic for ZingEvents\r\n */\r\n\r\nimport util from '../util.js';\r\n\r\nconst INITIAL_COORDINATE = 0;\r\n/**\r\n * An event wrapper that normalizes events across browsers and input devices\r\n * @class ZingEvent\r\n */\r\nclass ZingEvent {\r\n  /**\r\n   * @constructor\r\n   * @param {Event} event - The event object being wrapped.\r\n   * @param {Array} event.touches - The number of touches on\r\n   *  a screen (mobile only).\r\n   * @param {Object} event.changedTouches - The TouchList representing\r\n   * points that participated in the event.\r\n   * @param {Number} touchIdentifier - The index of touch if applicable\r\n   */\r\n  constructor(event, touchIdentifier) {\r\n    /**\r\n     * The original event object.\r\n     * @type {Event}\r\n     */\r\n    this.originalEvent = event;\r\n\r\n    /**\r\n     * The type of event or null if it is an event not predetermined.\r\n     * @see util.normalizeEvent\r\n     * @type {String | null}\r\n     */\r\n    this.type = util.normalizeEvent[ event.type ];\r\n\r\n    /**\r\n     * The X coordinate for the event, based off of the client.\r\n     * @type {number}\r\n     */\r\n    this.x = INITIAL_COORDINATE;\r\n\r\n    /**\r\n     * The Y coordinate for the event, based off of the client.\r\n     * @type {number}\r\n     */\r\n    this.y = INITIAL_COORDINATE;\r\n\r\n    let eventObj;\r\n    if (event.touches && event.changedTouches) {\r\n      eventObj = Array.from(event.changedTouches).find( t => {\r\n        return t.identifier === touchIdentifier;\r\n      });\r\n    } else {\r\n      eventObj = event;\r\n    }\r\n\r\n    this.x = this.clientX = eventObj.clientX;\r\n    this.y = this.clientY = eventObj.clientY;\r\n\r\n    this.pageX = eventObj.pageX;\r\n    this.pageY = eventObj.pageY;\r\n\r\n    this.screenX = eventObj.screenX;\r\n    this.screenY = eventObj.screenY;\r\n  }\r\n}\r\n\r\nexport default ZingEvent;\r\n","/**\r\n * @file Input.js\r\n */\r\n\r\nimport ZingEvent from './ZingEvent.js';\r\n\r\n/**\r\n * Tracks a single input and contains information about the\r\n * current, previous, and initial events.\r\n * Contains the progress of each Input and it's associated gestures.\r\n * @class Input\r\n */\r\nclass Input {\r\n\r\n  /**\r\n   * Constructor function for the Input class.\r\n   * @param {Event} event - The Event object from the window\r\n   * @param {Number} [identifier=0] - The identifier for each input event\r\n   * (taken from event.changedTouches)\r\n   */\r\n  constructor(event, identifier) {\r\n    let currentEvent = new ZingEvent(event, identifier);\r\n\r\n    /**\r\n     * Holds the initial event object. A touchstart/mousedown event.\r\n     * @type {ZingEvent}\r\n     */\r\n    this.initial = currentEvent;\r\n\r\n    /**\r\n     * Holds the most current event for this Input, disregarding any other past,\r\n     * current, and future events that other Inputs participate in.\r\n     * e.g. This event ended in an 'end' event, but another Input is still\r\n     * participating in events -- this will not be updated in such cases.\r\n     * @type {ZingEvent}\r\n     */\r\n    this.current = currentEvent;\r\n\r\n    /**\r\n     * Holds the previous event that took place.\r\n     * @type {ZingEvent}\r\n     */\r\n    this.previous = currentEvent;\r\n\r\n    /**\r\n     * Refers to the event.touches index, or 0 if a simple mouse event occurred.\r\n     * @type {Number}\r\n     */\r\n    this.identifier = (typeof identifier !== 'undefined') ? identifier : 0;\r\n\r\n    /**\r\n     * Stores internal state between events for\r\n     * each gesture based off of the gesture's id.\r\n     * @type {Object}\r\n     */\r\n    this.progress = {};\r\n  }\r\n\r\n  /**\r\n   * Receives an input, updates the internal state of what the input has done.\r\n   * @param {Event} event - The event object to wrap with a ZingEvent.\r\n   * @param {Number} touchIdentifier - The index of inputs, from event.touches\r\n   */\r\n  update(event, touchIdentifier) {\r\n    this.previous = this.current;\r\n    this.current = new ZingEvent(event, touchIdentifier);\r\n  }\r\n\r\n  /**\r\n   * Returns the progress of the specified gesture.\r\n   * @param {String} id - The identifier for each unique Gesture's progress.\r\n   * @return {Object} - The progress of the gesture.\r\n   * Creates an empty object if no progress has begun.\r\n   */\r\n  getGestureProgress(id) {\r\n    if (!this.progress[id]) {\r\n      this.progress[id] = {};\r\n    }\r\n    return this.progress[id];\r\n  }\r\n\r\n  /**\r\n   * Returns the normalized current Event's type.\r\n   * @return {String} The current event's type ( start | move | end )\r\n   */\r\n  getCurrentEventType() {\r\n    return this.current.type;\r\n  }\r\n\r\n  /**\r\n   * Resets a progress/state object of the specified gesture.\r\n   * @param {String} id - The identifier of the specified gesture\r\n   */\r\n  resetProgress(id) {\r\n    this.progress[id] = {};\r\n  }\r\n\r\n}\r\n\r\nexport default Input;\r\n","/**\r\n * @file State.js\r\n */\r\n\r\nimport Gesture from './../../gestures/Gesture.js';\r\nimport Pan from './../../gestures/Pan.js';\r\nimport Distance from './../../gestures/Distance.js';\r\nimport Rotate from './../../gestures/Rotate.js';\r\nimport Swipe from './../../gestures/Swipe.js';\r\nimport Tap from './../../gestures/Tap.js';\r\nimport Binding from './Binding.js';\r\nimport Input from './Input.js';\r\nimport util from './../util.js';\r\n\r\nconst DEFAULT_MOUSE_ID = 0;\r\n\r\n/**\r\n * Creates an object related to a Region's state,\r\n * and contains helper methods to update and clean up different states.\r\n */\r\nclass State {\r\n\r\n  /**\r\n   * Constructor for the State class.\r\n   * @param {String} regionId - The id the region this state is bound to.\r\n   */\r\n  constructor(regionId) {\r\n    /**\r\n     * The id for the region this state is bound to.\r\n     * @type {String}\r\n     */\r\n    this.regionId = regionId;\r\n\r\n    /**\r\n     * An array of current and recently inactive\r\n     *  Input objects related to a gesture.\r\n     * @type {Input}\r\n     */\r\n    this.inputs = [];\r\n\r\n    /**\r\n     * An array of Binding objects; The list of relations between elements,\r\n     *   their gestures, and the handlers.\r\n     * @type {Binding}\r\n     */\r\n    this.bindings = [];\r\n\r\n    /**\r\n     * The number of gestures that have been registered with this state\r\n     * @type {Number}\r\n     */\r\n    this.numGestures = 0;\r\n\r\n    /**\r\n     * A key/value map all the registered gestures for the listener.\r\n     *  Note: Can only have one gesture registered to one key.\r\n     * @type {Object}\r\n     */\r\n    this.registeredGestures = {};\r\n\r\n    this.registerGesture(new Pan(), 'pan');\r\n    this.registerGesture(new Rotate(), 'rotate');\r\n    this.registerGesture(new Distance(), 'distance');\r\n    this.registerGesture(new Swipe(), 'swipe');\r\n    this.registerGesture(new Tap(), 'tap');\r\n  }\r\n\r\n  /**\r\n   * Creates a new binding with the given element and gesture object.\r\n   * If the gesture object provided is unregistered, it's reference\r\n   * will be saved in as a binding to be later referenced.\r\n   * @param  {Element} element - The element the gesture is bound to.\r\n   * @param {String|Object} gesture  - Either a name of a registered gesture,\r\n   *  or an unregistered  Gesture object.\r\n   * @param {Function} handler - The function handler to be called\r\n   *  when the event is emitted. Used to bind/unbind.\r\n   * @param {Boolean} capture - Whether the gesture is to be\r\n   *  detected in the capture of bubble phase. Used to bind/unbind.\r\n   * @param {Boolean} bindOnce - Option to bind once and\r\n   *  only emit the event once.\r\n   */\r\n  addBinding(element, gesture, handler, capture, bindOnce) {\r\n    let boundGesture;\r\n\r\n    // Error type checking.\r\n    if (element && typeof element.tagName === 'undefined') {\r\n      throw new Error('Parameter element is an invalid object.');\r\n    }\r\n\r\n    if (typeof handler !== 'function') {\r\n      throw new Error('Parameter handler is invalid.');\r\n    }\r\n\r\n    if (typeof gesture === 'string' &&\r\n      Object.keys(this.registeredGestures).indexOf(gesture) === -1) {\r\n      throw new Error('Parameter ' + gesture + ' is not a registered gesture');\r\n    } else if (typeof gesture === 'object' && !(gesture instanceof Gesture)) {\r\n      throw new Error('Parameter for the gesture is not of a Gesture type');\r\n    }\r\n\r\n    if (typeof gesture === 'string') {\r\n      boundGesture = this.registeredGestures[gesture];\r\n    } else {\r\n      boundGesture = gesture;\r\n      if (boundGesture.id === '') {\r\n        this.assignGestureId(boundGesture);\r\n      }\r\n    }\r\n\r\n    this.bindings.push(new Binding(element, boundGesture,\r\n      handler, capture, bindOnce));\r\n    element.addEventListener(boundGesture.getId(), handler, capture);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the Binding by which an element is associated to.\r\n   * @param {Element} element - The element to find bindings to.\r\n   * @return {Array} - An array of Bindings to which that element is bound\r\n   */\r\n  retrieveBindingsByElement(element) {\r\n    return this.bindings.filter( b => b.element === element );\r\n  }\r\n\r\n  /**\r\n   * Retrieves all bindings based upon the initial X/Y position of the inputs.\r\n   * e.g. if gesture started on the correct target element,\r\n   *  but diverted away into the correct region, this would still be valid.\r\n   * @return {Array} - An array of Bindings to which that element is bound\r\n   */\r\n  retrieveBindingsByInitialPos() {\r\n    return this.bindings.filter( binding => {\r\n      return this.inputs.some( input => {\r\n        return util.isInside(input.initial.x, input.initial.y, binding.element);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates the inputs with new information based upon a new event being fired.\r\n   * @param {Event} event - The event being captured.\r\n   * @param {Element} regionElement - The element where\r\n   *  this current Region is bound to.\r\n   * @return {boolean} - returns true for a successful update,\r\n   *  false if the event is invalid.\r\n   */\r\n  updateInputs(event, regionElement) {\r\n    let eventType = (event.touches) ?\r\n      'TouchEvent' : ((event.pointerType) ? 'PointerEvent' : 'MouseEvent');\r\n    switch (eventType) {\r\n      case 'TouchEvent':\r\n        Array.from(event.changedTouches).forEach( touch => {\r\n          update(event, this, touch.identifier, regionElement);\r\n        });\r\n        break;\r\n\r\n      case 'PointerEvent':\r\n        update(event, this, event.pointerId, regionElement);\r\n        break;\r\n\r\n      case 'MouseEvent':\r\n      default:\r\n        update(event, this, DEFAULT_MOUSE_ID, regionElement);\r\n        break;\r\n    }\r\n    return true;\r\n\r\n    function update(event, state, identifier, regionElement) {\r\n      const eventType = util.normalizeEvent[ event.type ];\r\n      const input = findInputById(state.inputs, identifier);\r\n\r\n      // A starting input was not cleaned up properly and still exists.\r\n      if (eventType === 'start' && input) {\r\n        state.resetInputs();\r\n        return;\r\n      }\r\n\r\n      // An input has moved outside the region.\r\n      if (eventType !== 'start' &&\r\n        input &&\r\n        !util.isInside(input.current.x, input.current.y, regionElement)) {\r\n         state.resetInputs();\r\n        return;\r\n      }\r\n\r\n      if (eventType !== 'start' && !input) {\r\n        state.resetInputs();\r\n        return;\r\n      }\r\n\r\n      if (eventType === 'start') {\r\n        state.inputs.push(new Input(event, identifier));\r\n      } else {\r\n        input.update(event, identifier);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all inputs from the state, allowing for a new gesture.\r\n   */\r\n  resetInputs() {\r\n    this.inputs = [];\r\n  }\r\n\r\n  /**\r\n   * Counts the number of active inputs at any given time.\r\n   * @return {Number} - The number of active inputs.\r\n   */\r\n  numActiveInputs() {\r\n    const endType = this.inputs.filter((input) => {\r\n      return input.current.type !== 'end';\r\n    });\r\n    return endType.length;\r\n  }\r\n\r\n  /**\r\n   * Register the gesture to the current region.\r\n   * @param {Object} gesture - The gesture to register\r\n   * @param {String} key - The key to define the new gesture as.\r\n   */\r\n  registerGesture(gesture, key) {\r\n    this.assignGestureId(gesture);\r\n    this.registeredGestures[key] = gesture;\r\n  }\r\n\r\n  /**\r\n   * Tracks the gesture to this state object to become uniquely identifiable.\r\n   * Useful for nested Regions.\r\n   * @param {Gesture} gesture - The gesture to track\r\n   */\r\n  assignGestureId(gesture) {\r\n    gesture.setId(this.regionId + '-' + this.numGestures++);\r\n  }\r\n\r\n}\r\n/**\r\n * Searches through each input, comparing the browser's identifier key\r\n *  for touches, to the stored one in each input\r\n * @param {Array} inputs - The array of inputs in state.\r\n * @param {String} identifier - The identifier the browser has assigned.\r\n * @return {Input} - The input object with the corresponding identifier,\r\n *  null if it did not find any.\r\n */\r\nfunction findInputById(inputs, identifier) {\r\n  return inputs.find( i => i.identifier === identifier );\r\n}\r\n\r\nexport default State;\r\n","/**\r\n * @file Region.js\r\n */\r\n\r\nimport Binder from './Binder.js';\r\nimport Gesture from './../../gestures/Gesture.js';\r\nimport arbiter from './../arbiter.js';\r\nimport State from './State.js';\r\n\r\n/**\r\n * Allows the user to specify a region to capture all events to feed ZingTouch\r\n * into. This can be as narrow as the element itself, or as big as the document\r\n * itself. The more specific an area, the better performant the overall\r\n * application will perform. Contains API methods to bind/unbind specific\r\n * elements to corresponding gestures. Also contains the ability to\r\n * register/unregister new gestures.\r\n * @class Region\r\n */\r\nclass Region {\r\n\r\n  /**\r\n   * Constructor function for the Region class.\r\n   * @param {Element} element - The element to capture all\r\n   *  window events in that region to feed into ZingTouch.\r\n   * @param {boolean} [capture=false] - Whether the region listens for\r\n   *  captures or bubbles.\r\n   * @param {boolean} [preventDefault=true] - Whether the default browser\r\n   *  functionality should be disabled;\r\n   * @param {Number} id - The id of the region, assigned by the ZingTouch object\r\n   */\r\n  constructor(element, capture, preventDefault, id) {\r\n    /**\r\n     * The identifier for the Region. This is assigned by the ZingTouch object\r\n     * and is used to hash gesture id for uniqueness.\r\n     * @type {Number}\r\n     */\r\n    this.id = id;\r\n\r\n    /**\r\n     * The element being bound to.\r\n     * @type {Element}\r\n     */\r\n    this.element = element;\r\n\r\n    /**\r\n     * Whether the region listens for captures or bubbles.\r\n     * @type {boolean}\r\n     */\r\n    this.capture = (typeof capture !== 'undefined') ? capture : false;\r\n\r\n    /**\r\n     * Boolean to disable browser functionality such as scrolling and zooming\r\n     * over the region\r\n     * @type {boolean}\r\n     */\r\n    this.preventDefault = (typeof preventDefault !== 'undefined') ?\r\n      preventDefault : true;\r\n\r\n    /**\r\n     * The internal state object for a Region.\r\n     * Keeps track of registered gestures, inputs, and events.\r\n     * @type {State}\r\n     */\r\n    this.state = new State(id);\r\n\r\n    let eventNames = [];\r\n    if (window.PointerEvent && !window.TouchEvent) {\r\n      eventNames = [\r\n        'pointerdown',\r\n        'pointermove',\r\n        'pointerup',\r\n      ];\r\n    } else {\r\n      eventNames = [\r\n        'mousedown',\r\n        'mousemove',\r\n        'mouseup',\r\n        'touchstart',\r\n        'touchmove',\r\n        'touchend',\r\n      ];\r\n    }\r\n\r\n    // Bind detected browser events to the region element.\r\n    eventNames.forEach((name) => {\r\n      element.addEventListener(name, (e) => {\r\n        arbiter(e, this);\r\n      }, this.capture);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Bind an element to a registered/unregistered gesture with\r\n   * multiple function signatures.\r\n   * @example\r\n   * bind(element) - chainable\r\n   * @example\r\n   * bind(element, gesture, handler, [capture])\r\n   * @param {Element} element - The element object.\r\n   * @param {String|Object} [gesture] - Gesture key, or a Gesture object.\r\n   * @param {Function} [handler] - The function to execute when an event is\r\n   *  emitted.\r\n   * @param {Boolean} [capture] - capture/bubble\r\n   * @param {Boolean} [bindOnce = false] - Option to bind once and\r\n   *  only emit the event once.\r\n   * @return {Object} - a chainable object that has the same function as bind.\r\n   */\r\n  bind(element, gesture, handler, capture, bindOnce) {\r\n    if (!element || (element && !element.tagName)) {\r\n      throw 'Bind must contain an element';\r\n    }\r\n\r\n    bindOnce = (typeof bindOnce !== 'undefined') ? bindOnce : false;\r\n    if (!gesture) {\r\n      return new Binder(element, bindOnce, this.state);\r\n    } else {\r\n      this.state.addBinding(element, gesture, handler, capture, bindOnce);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bind an element and sets up actions to remove the binding once\r\n   * it has been emitted for the first time.\r\n   * 1. bind(element) - chainable\r\n   * 2. bind(element, gesture, handler, [capture])\r\n   * @param {Element} element - The element object.\r\n   * @param {String|Object} gesture - Gesture key, or a Gesture object.\r\n   * @param {Function} handler - The function to execute when an\r\n   *  event is emitted.\r\n   * @param {Boolean} capture - capture/bubble\r\n   * @return {Object} - a chainable object that has the same function as bind.\r\n   */\r\n  bindOnce(element, gesture, handler, capture) {\r\n    this.bind(element, gesture, handler, capture, true);\r\n  }\r\n\r\n  /**\r\n   * Unbinds an element from either the specified gesture\r\n   *  or all if no element is specified.\r\n   * @param {Element} element -The element to remove.\r\n   * @param {String | Object} [gesture] - A String representing the gesture,\r\n   *   or the actual object being used.\r\n   * @return {Array} - An array of Bindings that were unbound to the element;\r\n   */\r\n  unbind(element, gesture) {\r\n    let bindings = this.state.retrieveBindingsByElement(element);\r\n    let unbound = [];\r\n\r\n    bindings.forEach((binding) => {\r\n      if (gesture) {\r\n        if (typeof gesture === 'string' &&\r\n          this.state.registeredGestures[gesture]) {\r\n          let registeredGesture = this.state.registeredGestures[gesture];\r\n          if (registeredGesture.id === binding.gesture.id) {\r\n            element.removeEventListener(\r\n              binding.gesture.getId(),\r\n              binding.handler, binding.capture);\r\n            unbound.push(binding);\r\n          }\r\n        }\r\n      } else {\r\n        element.removeEventListener(\r\n          binding.gesture.getId(),\r\n          binding.handler,\r\n          binding.capture);\r\n        unbound.push(binding);\r\n      }\r\n    });\r\n\r\n    return unbound;\r\n  }\r\n\r\n  /* unbind*/\r\n\r\n  /**\r\n   * Registers a new gesture with an assigned key\r\n   * @param {String} key - The key used to register an element to that gesture\r\n   * @param {Gesture} gesture - A gesture object\r\n   */\r\n  register(key, gesture) {\r\n    if (typeof key !== 'string') {\r\n      throw new Error('Parameter key is an invalid string');\r\n    }\r\n\r\n    if (!gesture instanceof Gesture) {\r\n      throw new Error('Parameter gesture is an invalid Gesture object');\r\n    }\r\n\r\n    gesture.setType(key);\r\n    this.state.registerGesture(gesture, key);\r\n  }\r\n\r\n  /* register*/\r\n\r\n  /**\r\n   * Un-registers a gesture from the Region's state such that\r\n   * it is no longer emittable.\r\n   * Unbinds all events that were registered with the type.\r\n   * @param {String|Object} key - Gesture key that was used to\r\n   *  register the object\r\n   * @return {Object} - The Gesture object that was unregistered\r\n   *  or null if it could not be found.\r\n   */\r\n  unregister(key) {\r\n    this.state.bindings.forEach((binding) => {\r\n      if (binding.gesture.getType() === key) {\r\n        binding.element.removeEventListener(binding.gesture.getId(),\r\n          binding.handler, binding.capture);\r\n      }\r\n    });\r\n\r\n    let registeredGesture = this.state.registeredGestures[key];\r\n    delete this.state.registeredGestures[key];\r\n    return registeredGesture;\r\n  }\r\n}\r\n\r\nexport default Region;\r\n","/**\r\n * @file ZingTouch.js\r\n * Main object containing API methods and Gesture constructors\r\n */\r\n\r\nimport Region from './core/classes/Region.js';\r\nimport Gesture from './gestures/Gesture.js';\r\nimport Pan from './gestures/Pan.js';\r\nimport Distance from './gestures/Distance.js';\r\nimport Rotate from './gestures/Rotate.js';\r\nimport Swipe from './gestures/Swipe.js';\r\nimport Tap from './gestures/Tap.js';\r\n\r\n/**\r\n * The global API interface for ZingTouch. Contains a constructor for the\r\n * Region Object, and constructors for each predefined Gesture.\r\n * @type {Object}\r\n * @namespace ZingTouch\r\n */\r\nlet ZingTouch = {\r\n  _regions: [],\r\n\r\n  // Constructors\r\n  Gesture,\r\n  Pan,\r\n  Distance,\r\n  Rotate,\r\n  Swipe,\r\n  Tap,\r\n  Region: function(element, capture, preventDefault) {\r\n    let id = ZingTouch._regions.length;\r\n    let region = new Region(element, capture, preventDefault, id);\r\n    ZingTouch._regions.push(region);\r\n    return region;\r\n  },\r\n};\r\n\r\nexport default ZingTouch;\r\n","/**\r\n * @file main.js\r\n * Main file to setup event listeners on the document,\r\n * and to expose the ZingTouch object\r\n */\r\n\r\nimport ZingTouch from './../ZingTouch.js';\r\n\r\nif (typeof window !== 'undefined') {\r\n  window.ZingTouch = ZingTouch;\r\n}\r\n\r\nexport default ZingTouch;\r\n"],"sourceRoot":""}