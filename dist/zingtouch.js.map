{"version":3,"sources":["webpack://ZingTouch/webpack/universalModuleDefinition","webpack://ZingTouch/webpack/bootstrap","webpack://ZingTouch/./src/ZingTouch.js","webpack://ZingTouch/./src/core/arbiter.js","webpack://ZingTouch/./src/core/classes/Binder.js","webpack://ZingTouch/./src/core/classes/Binding.js","webpack://ZingTouch/./src/core/classes/Input.js","webpack://ZingTouch/./src/core/classes/Region.js","webpack://ZingTouch/./src/core/classes/State.js","webpack://ZingTouch/./src/core/classes/ZingEvent.js","webpack://ZingTouch/./src/core/dispatcher.js","webpack://ZingTouch/./src/core/interpreter.js","webpack://ZingTouch/./src/core/main.js","webpack://ZingTouch/./src/core/util.js","webpack://ZingTouch/./src/gestures/Distance.js","webpack://ZingTouch/./src/gestures/Gesture.js","webpack://ZingTouch/./src/gestures/Pan.js","webpack://ZingTouch/./src/gestures/Rotate.js","webpack://ZingTouch/./src/gestures/Swipe.js","webpack://ZingTouch/./src/gestures/Tap.js"],"names":["ZingTouch","_regions","Gesture","Pan","Distance","Rotate","Swipe","Tap","Region","element","capture","preventDefault","id","length","region","push","arbiter","event","state","eventType","normalizeEvent","type","inputs","buttons","resetInputs","updateInputs","bindings","retrieveBindingsByInitialPos","util","setMSPreventDefault","removeMSPreventDefault","toBeDispatched","gestures","path","getPropagationPath","forEach","gesture","binding","getId","getPathIndex","Object","keys","index","dispatcher","data","events","endCount","input","getCurrentEventType","Binder","bindOnce","registeredGestures","key","handler","addBinding","Binding","Input","identifier","currentEvent","initial","current","previous","progress","touchIdentifier","eventNames","window","PointerEvent","TouchEvent","name","addEventListener","e","tagName","bind","retrieveBindingsByElement","unbound","registeredGesture","removeEventListener","Error","setType","registerGesture","getType","DEFAULT_MOUSE_ID","State","regionId","numGestures","boundGesture","indexOf","assignGestureId","filter","b","some","isInside","x","y","regionElement","touches","pointerType","Array","from","changedTouches","touch","update","pointerId","findInputById","endType","setId","find","i","INITIAL_COORDINATE","ZingEvent","originalEvent","eventObj","t","clientX","clientY","pageX","pageY","screenX","screenY","newEvent","CustomEvent","detail","bubbles","cancelable","emitEvent","target","dispatchEvent","unbind","interpreter","evType","map","candidates","reduce","accumulator","freeze","mousedown","touchstart","pointerdown","mousemove","touchmove","pointermove","mouseup","touchend","pointerup","isWithin","currentX","currentY","previousX","previousY","tolerance","Math","abs","distanceBetweenTwoPoints","x0","x1","y0","y1","hypot","getMidpoint","getAngle","originX","originY","projectionX","projectionY","atan2","getAngularDistance","start","end","getVelocity","startX","startY","startTime","endX","endY","endTime","distance","getRightMostInput","rightMost","Number","MIN_VALUE","isInteger","value","clientLeft","clientWidth","clientTop","clientHeight","node","document","parentNode","obj","style","returnValue","DEFAULT_INPUTS","DEFAULT_MIN_THRESHOLD","options","threshold","isValid","getGestureProgress","lastEmittedDistance","numActiveInputs","currentDistance","centerPoint","change","center","object","every","numInputs","active","lastEmitted","output","distanceFromLastEmit","reachedThreshold","packData","distanceFromOrigin","directionFromOrigin","currentDirection","currentPivot","initialPivot","bRect","getBoundingClientRect","left","width","top","height","currentAngle","initialAngle","previousAngle","angle","distanceFromLast","DEFAULT_MAX_REST_TIME","DEFAULT_ESCAPE_VELOCITY","DEFAULT_TIME_DISTORTION","DEFAULT_MAX_PROGRESS_STACK","maxRestTime","escapeVelocity","timeDistortion","maxProgressStack","moves","time","Date","getTime","shift","currentMove","pop","lastMove","velocity","duration","DEFAULT_MIN_DELAY_MS","DEFAULT_MAX_DELAY_MS","DEFAULT_MOVE_PX_TOLERANCE","minDelay","maxDelay","resetProgress","MAX_VALUE","interval"],"mappings":"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","file":"zingtouch.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ZingTouch\"] = factory();\n\telse\n\t\troot[\"ZingTouch\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/core/main.js\");\n","/**\r\n * @file ZingTouch.js\r\n * Main object containing API methods and Gesture constructors\r\n */\r\n\r\nimport Region from './core/classes/Region.js';\r\nimport Gesture from './gestures/Gesture.js';\r\nimport Pan from './gestures/Pan.js';\r\nimport Distance from './gestures/Distance.js';\r\nimport Rotate from './gestures/Rotate.js';\r\nimport Swipe from './gestures/Swipe.js';\r\nimport Tap from './gestures/Tap.js';\r\n\r\n/**\r\n * The global API interface for ZingTouch. Contains a constructor for the\r\n * Region Object, and constructors for each predefined Gesture.\r\n * @type {Object}\r\n * @namespace ZingTouch\r\n */\r\nlet ZingTouch = {\r\n  _regions: [],\r\n\r\n  // Constructors\r\n  Gesture,\r\n  Pan,\r\n  Distance,\r\n  Rotate,\r\n  Swipe,\r\n  Tap,\r\n  Region: function(element, capture, preventDefault) {\r\n    let id = ZingTouch._regions.length;\r\n    let region = new Region(element, capture, preventDefault, id);\r\n    ZingTouch._regions.push(region);\r\n    return region;\r\n  },\r\n};\r\n\r\nexport default ZingTouch;\r\n","/**\r\n * @file arbiter.js\r\n * Contains logic for the dispatcher\r\n */\r\n\r\nimport dispatcher from './dispatcher.js';\r\nimport interpreter from './interpreter.js';\r\nimport util from './util.js';\r\n\r\n/**\r\n * Function that handles event flow, negotiating with the interpreter,\r\n * and dispatcher.\r\n * 1. Receiving all touch events in the window.\r\n * 2. Determining which gestures are linked to the target element.\r\n * 3. Negotiating with the Interpreter what event should occur.\r\n * 4. Sending events to the dispatcher to emit events to the target.\r\n * @param {Event} event - The event emitted from the window object.\r\n * @param {Object} region - The region object of the current listener.\r\n */\r\nfunction arbiter(event, region) {\r\n  const state = region.state;\r\n  const eventType = util.normalizeEvent[ event.type ];\r\n\r\n  /*\r\n   Return if a gesture is not in progress and won't be. Also catches the case\r\n   where a previous event is in a partial state (2 finger pan, waits for both\r\n   inputs to reach touchend)\r\n   */\r\n  if (state.inputs.length === 0 && eventType !== 'start') {\r\n    return;\r\n  }\r\n\r\n  /*\r\n   Check for 'stale' or events that lost focus\r\n   (e.g. a pan goes off screen/off region.)\r\n   Does not affect mobile devices.\r\n   */\r\n  if (typeof event.buttons !== 'undefined' &&\r\n    eventType !== 'end' &&\r\n    event.buttons === 0) {\r\n    state.resetInputs();\r\n    return;\r\n  }\r\n\r\n  // Update the state with the new events. If the event is stopped, return;\r\n  if (!state.updateInputs(event, region.element)) {\r\n    return;\r\n  }\r\n\r\n  // Retrieve the initial target from any one of the inputs\r\n  const bindings = state.retrieveBindingsByInitialPos();\r\n  if (bindings.length > 0) {\r\n    if (region.preventDefault) {\r\n      util.setMSPreventDefault(region.element);\r\n      util.preventDefault(event);\r\n    } else {\r\n      util.removeMSPreventDefault(region.element);\r\n    }\r\n\r\n    const toBeDispatched = {};\r\n    const gestures = interpreter(bindings, event, state);\r\n\r\n    /* Determine the deepest path index to emit the event\r\n     from, to avoid duplicate events being fired. */\r\n\r\n    const path = util.getPropagationPath(event);\r\n    gestures.forEach((gesture) => {\r\n      const id = gesture.binding.gesture.getId();\r\n      if (toBeDispatched[id]) {\r\n        if (util.getPathIndex(path, gesture.binding.element) <\r\n          util.getPathIndex(path, toBeDispatched[id].binding.element)) {\r\n          toBeDispatched[id] = gesture;\r\n        }\r\n      } else {\r\n        toBeDispatched[id] = gesture;\r\n      }\r\n    });\r\n\r\n    Object.keys(toBeDispatched).forEach((index) => {\r\n      const gesture = toBeDispatched[index];\r\n      dispatcher(gesture.binding, gesture.data, gesture.events);\r\n    });\r\n  }\r\n\r\n  let endCount = 0;\r\n  state.inputs.forEach((input) => {\r\n    if (input.getCurrentEventType() === 'end') {\r\n      endCount++;\r\n    }\r\n  });\r\n\r\n  if (endCount === state.inputs.length) {\r\n    state.resetInputs();\r\n  }\r\n}\r\n\r\nexport default arbiter;\r\n","/**\r\n * @file Binder.js\r\n */\r\n\r\n/**\r\n * A chainable object that contains a single element to be bound upon.\r\n * Called from ZingTouch.bind(), and is used to chain over gesture callbacks.\r\n * @class\r\n */\r\nclass Binder {\r\n  /**\r\n   * Constructor function for the Binder class.\r\n   * @param {Element} element - The element to bind gestures to.\r\n   * @param {Boolean} bindOnce - Option to bind once and only emit\r\n   * the event once.\r\n   * @param {Object} state - The state of the Region that is being bound to.\r\n   * @return {Object} - Returns 'this' to be chained over and over again.\r\n   */\r\n  constructor(element, bindOnce, state) {\r\n    /**\r\n     * The element to bind gestures to.\r\n     * @type {Element}\r\n     */\r\n    this.element = element;\r\n\r\n    Object.keys(state.registeredGestures).forEach((key) => {\r\n      this[key] = (handler, capture) => {\r\n        state.addBinding(this.element, key, handler, capture, bindOnce);\r\n        return this;\r\n      };\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport default Binder;\r\n","/**\r\n * @file Binding.js\r\n */\r\n\r\n/**\r\n * Responsible for creating a binding between an element and a gesture.\r\n * @class Binding\r\n */\r\nclass Binding {\r\n  /**\r\n   * Constructor function for the Binding class.\r\n   * @param {Element} element - The element to associate the gesture to.\r\n   * @param {Gesture} gesture - A instance of the Gesture type.\r\n   * @param {Function} handler - The function handler to execute when a\r\n   * gesture is recognized\r\n   * on the associated element.\r\n   * @param {Boolean} [capture=false] - A boolean signifying if the event is\r\n   * to be emitted during\r\n   * the capture or bubble phase.\r\n   * @param {Boolean} [bindOnce=false] - A boolean flag\r\n   * used for the bindOnce syntax.\r\n   */\r\n  constructor(element, gesture, handler, capture, bindOnce) {\r\n    /**\r\n     * The element to associate the gesture to.\r\n     * @type {Element}\r\n     */\r\n    this.element = element;\r\n    /**\r\n     * A instance of the Gesture type.\r\n     * @type {Gesture}\r\n     */\r\n    this.gesture = gesture;\r\n    /**\r\n     * The function handler to execute when a gesture is\r\n     * recognized on the associated element.\r\n     * @type {Function}\r\n     */\r\n    this.handler = handler;\r\n\r\n    /**\r\n     * A boolean signifying if the event is to be\r\n     * emitted during the capture or bubble phase.\r\n     * @type {Boolean}\r\n     */\r\n    this.capture = (typeof capture !== 'undefined') ? capture : false;\r\n\r\n    /**\r\n     * A boolean flag used for the bindOnce syntax.\r\n     * @type {Boolean}\r\n     */\r\n    this.bindOnce = (typeof bindOnce !== 'undefined') ? bindOnce : false;\r\n  }\r\n\r\n}\r\n\r\nexport default Binding;\r\n","/**\r\n * @file Input.js\r\n */\r\n\r\nimport ZingEvent from './ZingEvent.js';\r\n\r\n/**\r\n * Tracks a single input and contains information about the\r\n * current, previous, and initial events.\r\n * Contains the progress of each Input and it's associated gestures.\r\n * @class Input\r\n */\r\nclass Input {\r\n\r\n  /**\r\n   * Constructor function for the Input class.\r\n   * @param {Event} event - The Event object from the window\r\n   * @param {Number} [identifier=0] - The identifier for each input event\r\n   * (taken from event.changedTouches)\r\n   */\r\n  constructor(event, identifier) {\r\n    let currentEvent = new ZingEvent(event, identifier);\r\n\r\n    /**\r\n     * Holds the initial event object. A touchstart/mousedown event.\r\n     * @type {ZingEvent}\r\n     */\r\n    this.initial = currentEvent;\r\n\r\n    /**\r\n     * Holds the most current event for this Input, disregarding any other past,\r\n     * current, and future events that other Inputs participate in.\r\n     * e.g. This event ended in an 'end' event, but another Input is still\r\n     * participating in events -- this will not be updated in such cases.\r\n     * @type {ZingEvent}\r\n     */\r\n    this.current = currentEvent;\r\n\r\n    /**\r\n     * Holds the previous event that took place.\r\n     * @type {ZingEvent}\r\n     */\r\n    this.previous = currentEvent;\r\n\r\n    /**\r\n     * Refers to the event.touches index, or 0 if a simple mouse event occurred.\r\n     * @type {Number}\r\n     */\r\n    this.identifier = (typeof identifier !== 'undefined') ? identifier : 0;\r\n\r\n    /**\r\n     * Stores internal state between events for\r\n     * each gesture based off of the gesture's id.\r\n     * @type {Object}\r\n     */\r\n    this.progress = {};\r\n  }\r\n\r\n  /**\r\n   * Receives an input, updates the internal state of what the input has done.\r\n   * @param {Event} event - The event object to wrap with a ZingEvent.\r\n   * @param {Number} touchIdentifier - The index of inputs, from event.touches\r\n   */\r\n  update(event, touchIdentifier) {\r\n    this.previous = this.current;\r\n    this.current = new ZingEvent(event, touchIdentifier);\r\n  }\r\n\r\n  /**\r\n   * Returns the progress of the specified gesture.\r\n   * @param {String} id - The identifier for each unique Gesture's progress.\r\n   * @return {Object} - The progress of the gesture.\r\n   * Creates an empty object if no progress has begun.\r\n   */\r\n  getGestureProgress(id) {\r\n    if (!this.progress[id]) {\r\n      this.progress[id] = {};\r\n    }\r\n    return this.progress[id];\r\n  }\r\n\r\n  /**\r\n   * Returns the normalized current Event's type.\r\n   * @return {String} The current event's type ( start | move | end )\r\n   */\r\n  getCurrentEventType() {\r\n    return this.current.type;\r\n  }\r\n\r\n  /**\r\n   * Resets a progress/state object of the specified gesture.\r\n   * @param {String} id - The identifier of the specified gesture\r\n   */\r\n  resetProgress(id) {\r\n    this.progress[id] = {};\r\n  }\r\n\r\n}\r\n\r\nexport default Input;\r\n","/**\r\n * @file Region.js\r\n */\r\n\r\nimport Binder from './Binder.js';\r\nimport Gesture from './../../gestures/Gesture.js';\r\nimport arbiter from './../arbiter.js';\r\nimport State from './State.js';\r\n\r\n/**\r\n * Allows the user to specify a region to capture all events to feed ZingTouch\r\n * into. This can be as narrow as the element itself, or as big as the document\r\n * itself. The more specific an area, the better performant the overall\r\n * application will perform. Contains API methods to bind/unbind specific\r\n * elements to corresponding gestures. Also contains the ability to\r\n * register/unregister new gestures.\r\n * @class Region\r\n */\r\nclass Region {\r\n\r\n  /**\r\n   * Constructor function for the Region class.\r\n   * @param {Element} element - The element to capture all\r\n   *  window events in that region to feed into ZingTouch.\r\n   * @param {boolean} [capture=false] - Whether the region listens for\r\n   *  captures or bubbles.\r\n   * @param {boolean} [preventDefault=true] - Whether the default browser\r\n   *  functionality should be disabled;\r\n   * @param {Number} id - The id of the region, assigned by the ZingTouch object\r\n   */\r\n  constructor(element, capture, preventDefault, id) {\r\n    /**\r\n     * The identifier for the Region. This is assigned by the ZingTouch object\r\n     * and is used to hash gesture id for uniqueness.\r\n     * @type {Number}\r\n     */\r\n    this.id = id;\r\n\r\n    /**\r\n     * The element being bound to.\r\n     * @type {Element}\r\n     */\r\n    this.element = element;\r\n\r\n    /**\r\n     * Whether the region listens for captures or bubbles.\r\n     * @type {boolean}\r\n     */\r\n    this.capture = (typeof capture !== 'undefined') ? capture : false;\r\n\r\n    /**\r\n     * Boolean to disable browser functionality such as scrolling and zooming\r\n     * over the region\r\n     * @type {boolean}\r\n     */\r\n    this.preventDefault = (typeof preventDefault !== 'undefined') ?\r\n      preventDefault : true;\r\n\r\n    /**\r\n     * The internal state object for a Region.\r\n     * Keeps track of registered gestures, inputs, and events.\r\n     * @type {State}\r\n     */\r\n    this.state = new State(id);\r\n\r\n    let eventNames = [];\r\n    if (window.PointerEvent && !window.TouchEvent) {\r\n      eventNames = [\r\n        'pointerdown',\r\n        'pointermove',\r\n        'pointerup',\r\n      ];\r\n    } else {\r\n      eventNames = [\r\n        'mousedown',\r\n        'mousemove',\r\n        'mouseup',\r\n        'touchstart',\r\n        'touchmove',\r\n        'touchend',\r\n      ];\r\n    }\r\n\r\n    // Bind detected browser events to the region element.\r\n    eventNames.forEach((name) => {\r\n      element.addEventListener(name, (e) => {\r\n        arbiter(e, this);\r\n      }, this.capture);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Bind an element to a registered/unregistered gesture with\r\n   * multiple function signatures.\r\n   * @example\r\n   * bind(element) - chainable\r\n   * @example\r\n   * bind(element, gesture, handler, [capture])\r\n   * @param {Element} element - The element object.\r\n   * @param {String|Object} [gesture] - Gesture key, or a Gesture object.\r\n   * @param {Function} [handler] - The function to execute when an event is\r\n   *  emitted.\r\n   * @param {Boolean} [capture] - capture/bubble\r\n   * @param {Boolean} [bindOnce = false] - Option to bind once and\r\n   *  only emit the event once.\r\n   * @return {Object} - a chainable object that has the same function as bind.\r\n   */\r\n  bind(element, gesture, handler, capture, bindOnce) {\r\n    if (!element || (element && !element.tagName)) {\r\n      throw 'Bind must contain an element';\r\n    }\r\n\r\n    bindOnce = (typeof bindOnce !== 'undefined') ? bindOnce : false;\r\n    if (!gesture) {\r\n      return new Binder(element, bindOnce, this.state);\r\n    } else {\r\n      this.state.addBinding(element, gesture, handler, capture, bindOnce);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bind an element and sets up actions to remove the binding once\r\n   * it has been emitted for the first time.\r\n   * 1. bind(element) - chainable\r\n   * 2. bind(element, gesture, handler, [capture])\r\n   * @param {Element} element - The element object.\r\n   * @param {String|Object} gesture - Gesture key, or a Gesture object.\r\n   * @param {Function} handler - The function to execute when an\r\n   *  event is emitted.\r\n   * @param {Boolean} capture - capture/bubble\r\n   * @return {Object} - a chainable object that has the same function as bind.\r\n   */\r\n  bindOnce(element, gesture, handler, capture) {\r\n    this.bind(element, gesture, handler, capture, true);\r\n  }\r\n\r\n  /**\r\n   * Unbinds an element from either the specified gesture\r\n   *  or all if no element is specified.\r\n   * @param {Element} element -The element to remove.\r\n   * @param {String | Object} [gesture] - A String representing the gesture,\r\n   *   or the actual object being used.\r\n   * @return {Array} - An array of Bindings that were unbound to the element;\r\n   */\r\n  unbind(element, gesture) {\r\n    let bindings = this.state.retrieveBindingsByElement(element);\r\n    let unbound = [];\r\n\r\n    bindings.forEach((binding) => {\r\n      if (gesture) {\r\n        if (typeof gesture === 'string' &&\r\n          this.state.registeredGestures[gesture]) {\r\n          let registeredGesture = this.state.registeredGestures[gesture];\r\n          if (registeredGesture.id === binding.gesture.id) {\r\n            element.removeEventListener(\r\n              binding.gesture.getId(),\r\n              binding.handler, binding.capture);\r\n            unbound.push(binding);\r\n          }\r\n        }\r\n      } else {\r\n        element.removeEventListener(\r\n          binding.gesture.getId(),\r\n          binding.handler,\r\n          binding.capture);\r\n        unbound.push(binding);\r\n      }\r\n    });\r\n\r\n    return unbound;\r\n  }\r\n\r\n  /* unbind*/\r\n\r\n  /**\r\n   * Registers a new gesture with an assigned key\r\n   * @param {String} key - The key used to register an element to that gesture\r\n   * @param {Gesture} gesture - A gesture object\r\n   */\r\n  register(key, gesture) {\r\n    if (typeof key !== 'string') {\r\n      throw new Error('Parameter key is an invalid string');\r\n    }\r\n\r\n    if (!gesture instanceof Gesture) {\r\n      throw new Error('Parameter gesture is an invalid Gesture object');\r\n    }\r\n\r\n    gesture.setType(key);\r\n    this.state.registerGesture(gesture, key);\r\n  }\r\n\r\n  /* register*/\r\n\r\n  /**\r\n   * Un-registers a gesture from the Region's state such that\r\n   * it is no longer emittable.\r\n   * Unbinds all events that were registered with the type.\r\n   * @param {String|Object} key - Gesture key that was used to\r\n   *  register the object\r\n   * @return {Object} - The Gesture object that was unregistered\r\n   *  or null if it could not be found.\r\n   */\r\n  unregister(key) {\r\n    this.state.bindings.forEach((binding) => {\r\n      if (binding.gesture.getType() === key) {\r\n        binding.element.removeEventListener(binding.gesture.getId(),\r\n          binding.handler, binding.capture);\r\n      }\r\n    });\r\n\r\n    let registeredGesture = this.state.registeredGestures[key];\r\n    delete this.state.registeredGestures[key];\r\n    return registeredGesture;\r\n  }\r\n}\r\n\r\nexport default Region;\r\n","/**\r\n * @file State.js\r\n */\r\n\r\nimport Gesture from './../../gestures/Gesture.js';\r\nimport Pan from './../../gestures/Pan.js';\r\nimport Distance from './../../gestures/Distance.js';\r\nimport Rotate from './../../gestures/Rotate.js';\r\nimport Swipe from './../../gestures/Swipe.js';\r\nimport Tap from './../../gestures/Tap.js';\r\nimport Binding from './Binding.js';\r\nimport Input from './Input.js';\r\nimport util from './../util.js';\r\n\r\nconst DEFAULT_MOUSE_ID = 0;\r\n\r\n/**\r\n * Creates an object related to a Region's state,\r\n * and contains helper methods to update and clean up different states.\r\n */\r\nclass State {\r\n\r\n  /**\r\n   * Constructor for the State class.\r\n   * @param {String} regionId - The id the region this state is bound to.\r\n   */\r\n  constructor(regionId) {\r\n    /**\r\n     * The id for the region this state is bound to.\r\n     * @type {String}\r\n     */\r\n    this.regionId = regionId;\r\n\r\n    /**\r\n     * An array of current and recently inactive\r\n     *  Input objects related to a gesture.\r\n     * @type {Input}\r\n     */\r\n    this.inputs = [];\r\n\r\n    /**\r\n     * An array of Binding objects; The list of relations between elements,\r\n     *   their gestures, and the handlers.\r\n     * @type {Binding}\r\n     */\r\n    this.bindings = [];\r\n\r\n    /**\r\n     * The number of gestures that have been registered with this state\r\n     * @type {Number}\r\n     */\r\n    this.numGestures = 0;\r\n\r\n    /**\r\n     * A key/value map all the registered gestures for the listener.\r\n     *  Note: Can only have one gesture registered to one key.\r\n     * @type {Object}\r\n     */\r\n    this.registeredGestures = {};\r\n\r\n    this.registerGesture(new Pan(), 'pan');\r\n    this.registerGesture(new Rotate(), 'rotate');\r\n    this.registerGesture(new Distance(), 'distance');\r\n    this.registerGesture(new Swipe(), 'swipe');\r\n    this.registerGesture(new Tap(), 'tap');\r\n  }\r\n\r\n  /**\r\n   * Creates a new binding with the given element and gesture object.\r\n   * If the gesture object provided is unregistered, it's reference\r\n   * will be saved in as a binding to be later referenced.\r\n   * @param  {Element} element - The element the gesture is bound to.\r\n   * @param {String|Object} gesture  - Either a name of a registered gesture,\r\n   *  or an unregistered  Gesture object.\r\n   * @param {Function} handler - The function handler to be called\r\n   *  when the event is emitted. Used to bind/unbind.\r\n   * @param {Boolean} capture - Whether the gesture is to be\r\n   *  detected in the capture of bubble phase. Used to bind/unbind.\r\n   * @param {Boolean} bindOnce - Option to bind once and\r\n   *  only emit the event once.\r\n   */\r\n  addBinding(element, gesture, handler, capture, bindOnce) {\r\n    let boundGesture;\r\n\r\n    // Error type checking.\r\n    if (element && typeof element.tagName === 'undefined') {\r\n      throw new Error('Parameter element is an invalid object.');\r\n    }\r\n\r\n    if (typeof handler !== 'function') {\r\n      throw new Error('Parameter handler is invalid.');\r\n    }\r\n\r\n    if (typeof gesture === 'string' &&\r\n      Object.keys(this.registeredGestures).indexOf(gesture) === -1) {\r\n      throw new Error('Parameter ' + gesture + ' is not a registered gesture');\r\n    } else if (typeof gesture === 'object' && !(gesture instanceof Gesture)) {\r\n      throw new Error('Parameter for the gesture is not of a Gesture type');\r\n    }\r\n\r\n    if (typeof gesture === 'string') {\r\n      boundGesture = this.registeredGestures[gesture];\r\n    } else {\r\n      boundGesture = gesture;\r\n      if (boundGesture.id === '') {\r\n        this.assignGestureId(boundGesture);\r\n      }\r\n    }\r\n\r\n    this.bindings.push(new Binding(element, boundGesture,\r\n      handler, capture, bindOnce));\r\n    element.addEventListener(boundGesture.getId(), handler, capture);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the Binding by which an element is associated to.\r\n   * @param {Element} element - The element to find bindings to.\r\n   * @return {Array} - An array of Bindings to which that element is bound\r\n   */\r\n  retrieveBindingsByElement(element) {\r\n    return this.bindings.filter( b => b.element === element );\r\n  }\r\n\r\n  /**\r\n   * Retrieves all bindings based upon the initial X/Y position of the inputs.\r\n   * e.g. if gesture started on the correct target element,\r\n   *  but diverted away into the correct region, this would still be valid.\r\n   * @return {Array} - An array of Bindings to which that element is bound\r\n   */\r\n  retrieveBindingsByInitialPos() {\r\n    return this.bindings.filter( binding => {\r\n      return this.inputs.some( input => {\r\n        return util.isInside(input.initial.x, input.initial.y, binding.element);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates the inputs with new information based upon a new event being fired.\r\n   * @param {Event} event - The event being captured.\r\n   * @param {Element} regionElement - The element where\r\n   *  this current Region is bound to.\r\n   * @return {boolean} - returns true for a successful update,\r\n   *  false if the event is invalid.\r\n   */\r\n  updateInputs(event, regionElement) {\r\n    let eventType = (event.touches) ?\r\n      'TouchEvent' : ((event.pointerType) ? 'PointerEvent' : 'MouseEvent');\r\n    switch (eventType) {\r\n      case 'TouchEvent':\r\n        Array.from(event.changedTouches).forEach( touch => {\r\n          update(event, this, touch.identifier, regionElement);\r\n        });\r\n        break;\r\n\r\n      case 'PointerEvent':\r\n        update(event, this, event.pointerId, regionElement);\r\n        break;\r\n\r\n      case 'MouseEvent':\r\n      default:\r\n        update(event, this, DEFAULT_MOUSE_ID, regionElement);\r\n        break;\r\n    }\r\n    return true;\r\n\r\n    function update(event, state, identifier, regionElement) {\r\n      const eventType = util.normalizeEvent[ event.type ];\r\n      const input = findInputById(state.inputs, identifier);\r\n\r\n      // A starting input was not cleaned up properly and still exists.\r\n      if (eventType === 'start' && input) {\r\n        state.resetInputs();\r\n        return;\r\n      }\r\n\r\n      // An input has moved outside the region.\r\n      if (eventType !== 'start' &&\r\n        input &&\r\n        !util.isInside(input.current.x, input.current.y, regionElement)) {\r\n         state.resetInputs();\r\n        return;\r\n      }\r\n\r\n      if (eventType !== 'start' && !input) {\r\n        state.resetInputs();\r\n        return;\r\n      }\r\n\r\n      if (eventType === 'start') {\r\n        state.inputs.push(new Input(event, identifier));\r\n      } else {\r\n        input.update(event, identifier);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes all inputs from the state, allowing for a new gesture.\r\n   */\r\n  resetInputs() {\r\n    this.inputs = [];\r\n  }\r\n\r\n  /**\r\n   * Counts the number of active inputs at any given time.\r\n   * @return {Number} - The number of active inputs.\r\n   */\r\n  numActiveInputs() {\r\n    const endType = this.inputs.filter((input) => {\r\n      return input.current.type !== 'end';\r\n    });\r\n    return endType.length;\r\n  }\r\n\r\n  /**\r\n   * Register the gesture to the current region.\r\n   * @param {Object} gesture - The gesture to register\r\n   * @param {String} key - The key to define the new gesture as.\r\n   */\r\n  registerGesture(gesture, key) {\r\n    this.assignGestureId(gesture);\r\n    this.registeredGestures[key] = gesture;\r\n  }\r\n\r\n  /**\r\n   * Tracks the gesture to this state object to become uniquely identifiable.\r\n   * Useful for nested Regions.\r\n   * @param {Gesture} gesture - The gesture to track\r\n   */\r\n  assignGestureId(gesture) {\r\n    gesture.setId(this.regionId + '-' + this.numGestures++);\r\n  }\r\n\r\n}\r\n/**\r\n * Searches through each input, comparing the browser's identifier key\r\n *  for touches, to the stored one in each input\r\n * @param {Array} inputs - The array of inputs in state.\r\n * @param {String} identifier - The identifier the browser has assigned.\r\n * @return {Input} - The input object with the corresponding identifier,\r\n *  null if it did not find any.\r\n */\r\nfunction findInputById(inputs, identifier) {\r\n  return inputs.find( i => i.identifier === identifier );\r\n}\r\n\r\nexport default State;\r\n","/**\r\n * @file ZingEvent.js\r\n * Contains logic for ZingEvents\r\n */\r\n\r\nimport util from '../util.js';\r\n\r\nconst INITIAL_COORDINATE = 0;\r\n/**\r\n * An event wrapper that normalizes events across browsers and input devices\r\n * @class ZingEvent\r\n */\r\nclass ZingEvent {\r\n  /**\r\n   * @constructor\r\n   * @param {Event} event - The event object being wrapped.\r\n   * @param {Array} event.touches - The number of touches on\r\n   *  a screen (mobile only).\r\n   * @param {Object} event.changedTouches - The TouchList representing\r\n   * points that participated in the event.\r\n   * @param {Number} touchIdentifier - The index of touch if applicable\r\n   */\r\n  constructor(event, touchIdentifier) {\r\n    /**\r\n     * The original event object.\r\n     * @type {Event}\r\n     */\r\n    this.originalEvent = event;\r\n\r\n    /**\r\n     * The type of event or null if it is an event not predetermined.\r\n     * @see util.normalizeEvent\r\n     * @type {String | null}\r\n     */\r\n    this.type = util.normalizeEvent[ event.type ];\r\n\r\n    /**\r\n     * The X coordinate for the event, based off of the client.\r\n     * @type {number}\r\n     */\r\n    this.x = INITIAL_COORDINATE;\r\n\r\n    /**\r\n     * The Y coordinate for the event, based off of the client.\r\n     * @type {number}\r\n     */\r\n    this.y = INITIAL_COORDINATE;\r\n\r\n    let eventObj;\r\n    if (event.touches && event.changedTouches) {\r\n      eventObj = Array.from(event.changedTouches).find( t => {\r\n        return t.identifier === touchIdentifier;\r\n      });\r\n    } else {\r\n      eventObj = event;\r\n    }\r\n\r\n    this.x = this.clientX = eventObj.clientX;\r\n    this.y = this.clientY = eventObj.clientY;\r\n\r\n    this.pageX = eventObj.pageX;\r\n    this.pageY = eventObj.pageY;\r\n\r\n    this.screenX = eventObj.screenX;\r\n    this.screenY = eventObj.screenY;\r\n  }\r\n}\r\n\r\nexport default ZingEvent;\r\n","/**\r\n * @file dispatcher.js\r\n * Contains logic for the dispatcher\r\n */\r\n\r\n/**\r\n * Emits data at the target element if available, and bubbles up from\r\n * the target to the parent until the document has been reached.\r\n * Called from the arbiter.\r\n * @param {Binding} binding - An object of type Binding\r\n * @param {Object} data - The metadata computed by the gesture being emitted.\r\n * @param {Array} events - An array of ZingEvents\r\n *  corresponding to the inputs on the screen.\r\n */\r\nfunction dispatcher(binding, data, events) {\r\n  data.events = events;\r\n\r\n  const newEvent = new CustomEvent(binding.gesture.getId(), {\r\n    detail: data,\r\n    bubbles: true,\r\n    cancelable: true,\r\n  });\r\n  emitEvent(binding.element, newEvent, binding);\r\n}\r\n\r\n/**\r\n * Emits the new event. Unbinds the event if the event was registered\r\n * at bindOnce.\r\n * @param {Element} target - Element object to emit the event to.\r\n * @param {Event} event - The CustomEvent to emit.\r\n * @param {Binding} binding - An object of type Binding\r\n */\r\nfunction emitEvent(target, event, binding) {\r\n  target.dispatchEvent(event);\r\n  if (binding.bindOnce) {\r\n    ZingTouch.unbind(binding.element, binding.gesture.getType());\r\n  }\r\n}\r\n\r\nexport default dispatcher;\r\n","/**\r\n * @file interpreter.js\r\n * Contains logic for the interpreter\r\n */\r\n\r\nimport util from './util.js';\r\n\r\n/**\r\n * Receives an event and an array of Bindings (element -> gesture handler)\r\n * to determine what event will be emitted. Called from the arbiter.\r\n * @param {Array} bindings - An array containing Binding objects\r\n * that associate the element to an event handler.\r\n * @param {Object} event - The event emitted from the window.\r\n * @param {Object} state - The state object of the current listener.\r\n * @return {Object | null} - Returns an object containing a binding and\r\n * metadata, or null if a gesture will not be emitted.\r\n */\r\nfunction interpreter(bindings, event, state) {\r\n  const evType = util.normalizeEvent[ event.type ];\r\n  const events = state.inputs.map( input => input.current );\r\n\r\n  const candidates = bindings.reduce( (accumulator, binding) => {\r\n    const data = binding.gesture[evType](state.inputs, state, binding.element);\r\n    if (data) accumulator.push({ binding, data, events });\r\n    return accumulator;\r\n  }, []);\r\n\r\n  return candidates;\r\n}\r\n\r\nexport default interpreter;\r\n","/**\r\n * @file main.js\r\n * Main file to setup event listeners on the document,\r\n * and to expose the ZingTouch object\r\n */\r\n\r\nimport ZingTouch from './../ZingTouch.js';\r\n\r\nif (typeof window !== 'undefined') {\r\n  window.ZingTouch = ZingTouch;\r\n}\r\n\r\nexport default ZingTouch;\r\n","/**\r\n * @file util.js\r\n * Various accessor and mutator functions to handle state and validation.\r\n */\r\n\r\n/**\r\n *  Contains generic helper functions\r\n * @type {Object}\r\n * @namespace util\r\n */\r\nlet util = {\r\n\r\n  /**\r\n   * Normalizes window events to be either of type start, move, or end.\r\n   * @param {String} type - The event type emitted by the browser\r\n   * @return {null|String} - The normalized event, or null if it is an\r\n   * event not predetermined.\r\n   */\r\n  normalizeEvent: Object.freeze({\r\n      mousedown:   'start',\r\n      touchstart:  'start',\r\n      pointerdown: 'start',\r\n\r\n      mousemove:   'move',\r\n      touchmove:   'move',\r\n      pointermove: 'move',\r\n\r\n      mouseup:   'end',\r\n      touchend:  'end',\r\n      pointerup: 'end',\r\n  }),\r\n  /* normalizeEvent*/\r\n\r\n  /**\r\n   * Determines if the current and previous coordinates are within or\r\n   * up to a certain tolerance.\r\n   * @param {Number} currentX - Current event's x coordinate\r\n   * @param {Number} currentY - Current event's y coordinate\r\n   * @param {Number} previousX - Previous event's x coordinate\r\n   * @param {Number} previousY - Previous event's y coordinate\r\n   * @param {Number} tolerance - The tolerance in pixel value.\r\n   * @return {boolean} - true if the current coordinates are\r\n   * within the tolerance, false otherwise\r\n   */\r\n  isWithin(currentX, currentY, previousX, previousY, tolerance) {\r\n    return ((Math.abs(currentY - previousY) <= tolerance) &&\r\n    (Math.abs(currentX - previousX) <= tolerance));\r\n  },\r\n  /* isWithin*/\r\n\r\n  /**\r\n   * Calculates the distance between two points.\r\n   * @param {Number} x0\r\n   * @param {Number} x1\r\n   * @param {Number} y0\r\n   * @param {Number} y1\r\n   * @return {number} The numerical value between two points\r\n   */\r\n  distanceBetweenTwoPoints(x0, x1, y0, y1) {\r\n    return Math.hypot(x1 - x0, y1 - y0);\r\n  },\r\n\r\n  /**\r\n   * Calculates the midpoint coordinates between two points.\r\n   * @param {Number} x0\r\n   * @param {Number} x1\r\n   * @param {Number} y0\r\n   * @param {Number} y1\r\n   * @return {Object} The coordinates of the midpoint.\r\n   */\r\n  getMidpoint(x0, x1, y0, y1) {\r\n    return {\r\n      x: ((x0 + x1) / 2),\r\n      y: ((y0 + y1) / 2),\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Calculates the angle between the projection and an origin point.\r\n   *   |                (projectionX,projectionY)\r\n   *   |             /\r\n   *   |          /\r\n   *   |       /\r\n   *   |    / \r\n   *   | /__________\r\n   *    (originX, originY)\r\n   * @param {number} originX\r\n   * @param {number} originY\r\n   * @param {number} projectionX\r\n   * @param {number} projectionY\r\n   * @return {number} - Radians along the unit circle where the projection lies\r\n   */\r\n  getAngle(originX, originY, projectionX, projectionY) {\r\n    return Math.atan2(projectionY - originY, projectionX - originX);\r\n  },\r\n\r\n  /**\r\n   * Calculates the angular distance in radians between two angles along the\r\n   * unit circle\r\n   * @param {number} start - The starting point in radians\r\n   * @param {number} end - The ending point in radians\r\n   * @return {number} The number of radians between the starting point and\r\n   * ending point. \r\n   */\r\n  getAngularDistance(start, end) {\r\n    return end - start;\r\n  },\r\n\r\n  /**\r\n   * Calculates the velocity of pixel/milliseconds between two points\r\n   * @param {Number} startX\r\n   * @param {Number} startY\r\n   * @param {Number} startTime\r\n   * @param {Number} endX\r\n   * @param {Number} endY\r\n   * @param {Number} endTime\r\n   * @return {Number} velocity of px/time\r\n   */\r\n  getVelocity(startX, startY, startTime, endX, endY, endTime) {\r\n    let distance = this.distanceBetweenTwoPoints(startX, endX, startY, endY);\r\n    return (distance / (endTime - startTime));\r\n  },\r\n\r\n  /**\r\n   * Returns the farthest right input\r\n   * @param {Array} inputs\r\n   * @return {Object}\r\n   */\r\n  getRightMostInput(inputs) {\r\n    let rightMost = null;\r\n    let distance = Number.MIN_VALUE;\r\n    inputs.forEach((input) => {\r\n      if (input.initial.x > distance) {\r\n        rightMost = input;\r\n      }\r\n    });\r\n    return rightMost;\r\n  },\r\n\r\n  /**\r\n   * Determines is the value is an integer and not a floating point\r\n   * @param {Mixed} value\r\n   * @return {boolean}\r\n   */\r\n  isInteger(value) {\r\n    return (typeof value === 'number') && (value % 1 === 0);\r\n  },\r\n\r\n  /**\r\n   * Determines if the x,y position of the input is within then target.\r\n   * @param {Number} x -clientX\r\n   * @param {Number} y -clientY\r\n   * @param {Element} target\r\n   * @return {Boolean}\r\n   */\r\n  isInside(x, y, target) {\r\n    return ((x > target.clientLeft && x < target.clientLeft + target.clientWidth) &&\r\n            (y > target.clientTop  && y < target.clientTop  + target.clientHeight));\r\n  },\r\n  /**\r\n   * Polyfill for event.propagationPath\r\n   * @param {Event} event\r\n   * @return {Array}\r\n   */\r\n  getPropagationPath(event) {\r\n    if (event.path) {\r\n      return event.path;\r\n    } else {\r\n      let path = [];\r\n      let node = event.target;\r\n      while (node != document) {\r\n        path.push(node);\r\n        node = node.parentNode;\r\n      }\r\n\r\n      return path;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Retrieve the index inside the path array\r\n   * @param {Array} path\r\n   * @param {Element} element\r\n   * @return {Element}\r\n   */\r\n  getPathIndex(path, element) {\r\n    let index = path.length;\r\n\r\n    path.forEach((obj, i) => {\r\n      if (obj === element) {\r\n        index = i;\r\n      }\r\n    });\r\n\r\n    return index;\r\n  },\r\n\r\n  setMSPreventDefault(element) {\r\n    element.style['-ms-content-zooming'] = 'none';\r\n    element.style['touch-action'] = 'none';\r\n  },\r\n\r\n  removeMSPreventDefault(element) {\r\n    element.style['-ms-content-zooming'] = '';\r\n    element.style['touch-action'] = '';\r\n  },\r\n\r\n  preventDefault(event) {\r\n    if (event.preventDefault) {\r\n      event.preventDefault();\r\n    } else {\r\n      event.returnValue = false;\r\n    }\r\n  }\r\n};\r\n\r\nexport default util;\r\n","/**\r\n * @file Distance.js\r\n * Contains the abstract Distance class\r\n */\r\n\r\nimport Gesture from './Gesture.js';\r\nimport util from './../core/util.js';\r\n\r\nconst DEFAULT_INPUTS = 2;\r\nconst DEFAULT_MIN_THRESHOLD = 1;\r\n\r\n/**\r\n * A Distance is defined as two inputs moving either together or apart.\r\n * @class Distance\r\n */\r\nclass Distance extends Gesture {\r\n  /**\r\n   * Constructor function for the Distance class.\r\n   * @param {Object} options\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /**\r\n     * The type of the Gesture.\r\n     * @type {String}\r\n     */\r\n    this.type = 'distance';\r\n\r\n    /**\r\n     * The minimum amount in pixels the inputs must move until it is fired.\r\n     * @type {Number}\r\n     */\r\n    this.threshold = (options && options.threshold) ?\r\n      options.threshold : DEFAULT_MIN_THRESHOLD;\r\n  }\r\n\r\n  /**\r\n   * Event hook for the start of a gesture. Initialized the lastEmitted\r\n   * gesture and stores it in the first input for reference events.\r\n   * @param {Array} inputs\r\n   */\r\n  start(inputs, state, element) {\r\n    if(!this.isValid(inputs, state, element)) {\r\n      return null;\r\n    }\r\n    if (inputs.length === DEFAULT_INPUTS) {\r\n      // Store the progress in the first input.\r\n      const progress = inputs[0].getGestureProgress(this.getId());\r\n      progress.lastEmittedDistance = util.distanceBetweenTwoPoints(\r\n        inputs[0].current.x,\r\n        inputs[1].current.x,\r\n        inputs[0].current.y,\r\n        inputs[1].current.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Event hook for the move of a gesture.\r\n   *  Determines if the two points are moved in the expected direction relative\r\n   *  to the current distance and the last distance.\r\n   * @param {Array} inputs - The array of Inputs on the screen.\r\n   * @param {Object} state - The state object of the current region.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {Object | null} - Returns the distance in pixels between two inputs\r\n   */\r\n  move(inputs, state, element) {\r\n    if (state.numActiveInputs() === DEFAULT_INPUTS) {\r\n      const currentDistance = util.distanceBetweenTwoPoints(\r\n        inputs[0].current.x,\r\n        inputs[1].current.x,\r\n        inputs[0].current.y,\r\n        inputs[1].current.y);\r\n      const centerPoint = util.getMidpoint(\r\n        inputs[0].current.x,\r\n        inputs[1].current.x,\r\n        inputs[0].current.y,\r\n        inputs[1].current.y);\r\n\r\n      // Progress is stored in the first input.\r\n      const progress = inputs[0].getGestureProgress(this.getId());\r\n      const change = currentDistance - progress.lastEmittedDistance;\r\n\r\n      if (Math.abs(change) >= this.threshold) {\r\n        progress.lastEmittedDistance = currentDistance;\r\n        return {\r\n          distance: currentDistance,\r\n          center: centerPoint,\r\n          change,\r\n        };\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n}\r\n\r\nexport default Distance;\r\n","/**\r\n * @file Gesture.js\r\n * Contains the Gesture class\r\n */\r\n\r\nimport util from './../core/util.js';\r\n\r\n/**\r\n * The Gesture class that all gestures inherit from.\r\n */\r\nclass Gesture {\r\n  /**\r\n   * Constructor function for the Gesture class.\r\n   * @class Gesture\r\n   */\r\n  constructor() {\r\n    /**\r\n     * The generic string type of gesture ('expand'|'distance'|\r\n     *  'rotate'|'swipe'|'tap').\r\n     * @type {String}\r\n     */\r\n    this.type = null;\r\n\r\n    /**\r\n     * The unique identifier for each gesture determined at bind time by the\r\n     * state object. This allows for distinctions across instance variables of\r\n     * Gestures that are created on the fly (e.g. Tap-1, Tap-2, etc).\r\n     * @type {String|null}\r\n     */\r\n    this.id = null;\r\n  }\r\n\r\n  /**\r\n   * Set the type of the gesture to be called during an event\r\n   * @param {String} type - The unique identifier of the gesture being created.\r\n   */\r\n  setType(type) {\r\n    this.type = type;\r\n  }\r\n\r\n  /**\r\n   * getType() - Returns the generic type of the gesture\r\n   * @return {String} - The type of gesture\r\n   */\r\n  getType() {\r\n    return this.type;\r\n  }\r\n\r\n  /**\r\n   * Set the id of the gesture to be called during an event\r\n   * @param {String} id - The unique identifier of the gesture being created.\r\n   */\r\n  setId(id) {\r\n    this.id = id;\r\n  }\r\n\r\n  /**\r\n   * Return the id of the event. If the id does not exist, return the type.\r\n   * @return {String}\r\n   */\r\n  getId() {\r\n    return (this.id !== null) ? this.id : this.type;\r\n  }\r\n\r\n  /**\r\n   * Updates internal properties with new ones, only if the properties exist.\r\n   * @param {Object} object\r\n   */\r\n  update(object) {\r\n    Object.keys(object).forEach( key => {\r\n      this[key] = object[key];\r\n    });\r\n  }\r\n\r\n  /**\r\n   * start() - Event hook for the start of a gesture\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n\t * @param {Object} state - The state object of the current region.\r\n\t * @param {Element} element - The element associated to the binding.\r\n   * @return {null|Object}  - Default of null\r\n   */\r\n  start(inputs, state, element) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * move() - Event hook for the move of a gesture\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @param {Object} state - The state object of the current region.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {null|Object} - Default of null\r\n   */\r\n  move(inputs, state, element) {\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * end() - Event hook for the move of a gesture\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @return {null|Object}  - Default of null\r\n   */\r\n  end(inputs) {\r\n    return null;\r\n  }\r\n\r\n\t/**\r\n\t* isValid() - Pre-checks to ensure the invariants of a gesture are satisfied.\r\n\t* @param {Array} inputs - The array of Inputs on the screen\r\n\t* @param {Object} state - The state object of the current region.\r\n\t* @param {Element} element - The element associated to the binding.\r\n\t* @return {boolean} - If the gesture is valid\r\n\t*/\r\n\tisValid(inputs, state, element) {\r\n    return inputs.every( input => {\r\n        return util.isInside(input.initial.x, input.initial.y, element);\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport default Gesture;\r\n","/**\r\n * @file Pan.js\r\n * Contains the Pan class\r\n */\r\n\r\nimport Gesture from './Gesture.js';\r\nimport util from './../core/util.js';\r\n\r\nconst DEFAULT_INPUTS = 1;\r\nconst DEFAULT_MIN_THRESHOLD = 1;\r\n\r\n/**\r\n * A Pan is defined as a normal movement in any direction on a screen.\r\n * Pan gestures do not track start events and can interact with distance gestures\r\n * @class Pan\r\n */\r\nclass Pan extends Gesture {\r\n  /**\r\n   * Constructor function for the Pan class.\r\n   * @param {Object} [options] - The options object.\r\n   * @param {Number} [options.numInputs=1] - Number of inputs for the\r\n   *  Pan gesture.\r\n   * @param {Number} [options.threshold=1] - The minimum number of\r\n   * pixels the input has to move to trigger this gesture.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /**\r\n     * The type of the Gesture.\r\n     * @type {String}\r\n     */\r\n    this.type = 'pan';\r\n\r\n    /**\r\n     * The number of inputs to trigger a Pan can be variable,\r\n     * and the maximum number being a factor of the browser.\r\n     * @type {Number}\r\n     */\r\n    this.numInputs = (options && options.numInputs) ?\r\n      options.numInputs : DEFAULT_INPUTS;\r\n\r\n    /**\r\n     * The minimum amount in pixels the pan must move until it is fired.\r\n     * @type {Number}\r\n     */\r\n    this.threshold = (options && options.threshold) ?\r\n      options.threshold : DEFAULT_MIN_THRESHOLD;\r\n  }\r\n\r\n  /**\r\n   * Event hook for the start of a gesture. Marks each input as active,\r\n   * so it can invalidate any end events.\r\n   * @param {Array} inputs\r\n   */\r\n  start(inputs) {\r\n    inputs.forEach((input) => {\r\n      const progress = input.getGestureProgress(this.getId());\r\n      progress.active = true;\r\n      progress.lastEmitted = {\r\n        x: input.current.x,\r\n        y: input.current.y,\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * move() - Event hook for the move of a gesture.\r\n   * Fired whenever the input length is met, and keeps a boolean flag that\r\n   * the gesture has fired at least once.\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @param {Object} state - The state object of the current region.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {Object} - Returns the distance in pixels between the two inputs.\r\n   */\r\n  move(inputs, state, element) {\r\n    if (this.numInputs !== inputs.length) return null;\r\n\r\n    const output = {\r\n      data: [],\r\n    };\r\n\r\n    inputs.forEach( (input, index) => {\r\n      const progress = input.getGestureProgress(this.getId());\r\n      const distanceFromLastEmit = util.distanceBetweenTwoPoints(\r\n        progress.lastEmitted.x,\r\n        progress.lastEmitted.y,\r\n        input.current.x,\r\n        input.current.y\r\n      );\r\n      const reachedThreshold = distanceFromLastEmit >= this.threshold;\r\n\r\n      if (progress.active && reachedThreshold) {\r\n        output.data[index] = packData( input, progress );\r\n        progress.lastEmitted.x = input.current.x;\r\n        progress.lastEmitted.y = input.current.y;\r\n      }\r\n    });\r\n\r\n    return output;\r\n\r\n    function packData( input, progress ) {\r\n      const distanceFromOrigin = util.distanceBetweenTwoPoints(\r\n        input.initial.x,\r\n        input.current.x,\r\n        input.initial.y,\r\n        input.current.y\r\n      );\r\n      const directionFromOrigin = util.getAngle(\r\n        input.initial.x,\r\n        input.initial.y,\r\n        input.current.x,\r\n        input.current.y\r\n      );\r\n      const currentDirection = util.getAngle(\r\n        progress.lastEmitted.x,\r\n        progress.lastEmitted.y,\r\n        input.current.x,\r\n        input.current.y\r\n      );\r\n      const change = {\r\n        x: input.current.x - progress.lastEmitted.x,\r\n        y: input.current.y - progress.lastEmitted.y,\r\n      };\r\n\r\n      return {\r\n        distanceFromOrigin,\r\n        directionFromOrigin,\r\n        currentDirection,\r\n        change,\r\n      };\r\n    }\r\n  }\r\n\r\n  /* move*/\r\n\r\n  /**\r\n   * end() - Event hook for the end of a gesture. If the gesture has at least\r\n   * fired once, then it ends on the first end event such that any remaining\r\n   * inputs will not trigger the event until all inputs have reached the\r\n   * touchend event. Any touchend->touchstart events that occur before all\r\n   * inputs are fully off the screen should not fire.\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @return {null} - null if the gesture is not to be emitted,\r\n   *  Object with information otherwise.\r\n   */\r\n  end(inputs) {\r\n    inputs.forEach((input) => {\r\n      const progress = input.getGestureProgress(this.getId());\r\n      progress.active = false;\r\n    });\r\n    return null;\r\n  }\r\n\r\n  /* end*/\r\n}\r\n\r\nexport default Pan;\r\n","/**\r\n * @file Rotate.js\r\n * Contains the Rotate class\r\n */\r\n\r\nimport Gesture from './Gesture.js';\r\nimport util from './../core/util.js';\r\n\r\nconst DEFAULT_INPUTS = 2;\r\n\r\n/**\r\n * A Rotate is defined as two inputs moving about a circle,\r\n * maintaining a relatively equal radius.\r\n * @class Rotate\r\n */\r\nclass Rotate extends Gesture {\r\n  /**\r\n   * Constructor function for the Rotate class.\r\n   */\r\n  constructor(options = {}) {\r\n    super();\r\n\r\n    /**\r\n     * The type of the Gesture.\r\n     * @type {String}\r\n     */\r\n    this.type = 'rotate';\r\n\r\n    /**\r\n     * The number of touches required to emit Rotate events.\r\n     * @type {Number}\r\n     */\r\n    this.numInputs = options.numInputs || DEFAULT_INPUTS;\r\n  }\r\n\r\n  /**\r\n   * move() - Event hook for the move of a gesture. Obtains the midpoint of two\r\n   * the two inputs and calculates the projection of the right most input along\r\n   * a unit circle to obtain an angle. This angle is compared to the previously\r\n   * calculated angle to output the change of distance, and is compared to the\r\n   * initial angle to output the distance from the initial angle to the current\r\n   * angle.\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @param {Object} state - The state object of the current listener.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {null} - null if this event did not occur\r\n   * @return {Object} obj.angle - The current angle along the unit circle\r\n   * @return {Object} obj.distanceFromOrigin - The angular distance travelled\r\n   * from the initial right most point.\r\n   * @return {Object} obj.distanceFromLast - The change of angle between the\r\n   * last position and the current position.\r\n   */\r\n  move(inputs, state, element) {\r\n    const numActiveInputs = state.numActiveInputs();\r\n    if (this.numInputs !== numActiveInputs) return null;\r\n\r\n    let currentPivot, initialPivot;\r\n    let input;\r\n    if (numActiveInputs === 1) {\r\n      const bRect = element.getBoundingClientRect();\r\n      currentPivot = {\r\n        x: bRect.left + bRect.width / 2,\r\n        y: bRect.top + bRect.height / 2,\r\n      };\r\n      initialPivot = currentPivot;\r\n      input = inputs[0];\r\n    } else {\r\n      currentPivot = util.getMidpoint(\r\n        inputs[0].current.x,\r\n        inputs[1].current.x,\r\n        inputs[0].current.y,\r\n        inputs[1].current.y);\r\n      input = util.getRightMostInput(inputs);\r\n    }\r\n\r\n    // Translate the current pivot point.\r\n    const currentAngle = util.getAngle(\r\n      currentPivot.x, \r\n      currentPivot.y,\r\n      input.current.x,\r\n      input.current.y);\r\n\r\n    const progress = input.getGestureProgress(this.getId());\r\n    if (!progress.initialAngle) {\r\n      progress.initialAngle = progress.previousAngle = currentAngle;\r\n      progress.distance = progress.change = 0;\r\n    } else {\r\n      progress.change = util.getAngularDistance(\r\n        progress.previousAngle,\r\n        currentAngle);\r\n      progress.distance = progress.distance + progress.change;\r\n    }\r\n\r\n    progress.previousAngle = currentAngle;\r\n\r\n    return {\r\n      angle: currentAngle,\r\n      distanceFromOrigin: progress.distance,\r\n      distanceFromLast: progress.change,\r\n    };\r\n  }\r\n\r\n  /* move*/\r\n}\r\n\r\nexport default Rotate;\r\n","/**\r\n * @file Swipe.js\r\n * Contains the Swipe class\r\n */\r\n\r\nimport Gesture from './Gesture.js';\r\nimport util from './../core/util.js';\r\n\r\nconst DEFAULT_INPUTS = 1;\r\nconst DEFAULT_MAX_REST_TIME = 100;\r\nconst DEFAULT_ESCAPE_VELOCITY = 0.2;\r\nconst DEFAULT_TIME_DISTORTION = 100;\r\nconst DEFAULT_MAX_PROGRESS_STACK = 10;\r\n\r\n/**\r\n * A swipe is defined as input(s) moving in the same direction in an relatively\r\n * increasing velocity and leaving the screen at some point before it drops\r\n * below it's escape velocity.\r\n * @class Swipe\r\n */\r\nclass Swipe extends Gesture {\r\n\r\n  /**\r\n   * Constructor function for the Swipe class.\r\n   * @param {Object} [options] - The options object.\r\n   * @param {Number} [options.numInputs] - The number of inputs to trigger a\r\n   * Swipe can be variable, and the maximum number being a factor of the browser\r\n   *  move and current move events.\r\n   * @param {Number} [options.maxRestTime] - The maximum resting time a point\r\n   *  has between it's last\r\n   * @param {Number} [options.escapeVelocity] - The minimum velocity the input\r\n   *  has to be at to emit a swipe.\r\n   * @param {Number} [options.timeDistortion] - (EXPERIMENTAL) A value of time\r\n   *  in milliseconds to distort between events.\r\n   * @param {Number} [options.maxProgressStack] - (EXPERIMENTAL)The maximum\r\n   *  amount of move events to keep\r\n   * track of for a swipe.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n    /**\r\n     * The type of the Gesture\r\n     * @type {String}\r\n     */\r\n    this.type = 'swipe';\r\n\r\n    /**\r\n     * The number of inputs to trigger a Swipe can be variable,\r\n     * and the maximum number being a factor of the browser.\r\n     * @type {Number}\r\n     */\r\n    this.numInputs = (options && options.numInputs) ?\r\n      options.numInputs : DEFAULT_INPUTS;\r\n\r\n    /**\r\n     * The maximum resting time a point has between it's last move and\r\n     * current move events.\r\n     * @type {Number}\r\n     */\r\n    this.maxRestTime = (options && options.maxRestTime) ?\r\n      options.maxRestTime : DEFAULT_MAX_REST_TIME;\r\n\r\n    /**\r\n     * The minimum velocity the input has to be at to emit a swipe.\r\n     * This is useful for determining the difference between\r\n     * a swipe and a pan gesture.\r\n     * @type {number}\r\n     */\r\n    this.escapeVelocity = (options && options.escapeVelocity) ?\r\n      options.escapeVelocity : DEFAULT_ESCAPE_VELOCITY;\r\n\r\n    /**\r\n     * (EXPERIMENTAL) A value of time in milliseconds to distort between events.\r\n     * Browsers do not accurately measure time with the Date constructor in\r\n     * milliseconds, so consecutive events sometimes display the same timestamp\r\n     * but different x/y coordinates. This will distort a previous time\r\n     * in such cases by the timeDistortion's value.\r\n     * @type {number}\r\n     */\r\n    this.timeDistortion = (options && options.timeDistortion) ?\r\n      options.timeDistortion : DEFAULT_TIME_DISTORTION;\r\n\r\n    /**\r\n     * (EXPERIMENTAL) The maximum amount of move events to keep track of for a\r\n     * swipe. This helps give a more accurate estimate of the user's velocity.\r\n     * @type {number}\r\n     */\r\n    this.maxProgressStack = (options && options.maxProgressStack) ?\r\n      options.maxProgressStack : DEFAULT_MAX_PROGRESS_STACK;\r\n  }\r\n\r\n  /**\r\n   * Event hook for the move of a gesture. Captures an input's x/y coordinates\r\n   * and the time of it's event on a stack.\r\n   * @param {Array} inputs - The array of Inputs on the screen.\r\n   * @param {Object} state - The state object of the current region.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {null} - Swipe does not emit from a move.\r\n   */\r\n  move(inputs, state, element) {\r\n    if (this.numInputs === inputs.length) {\r\n      for (let i = 0; i < inputs.length; i++) {\r\n        let progress = inputs[i].getGestureProgress(this.getId());\r\n        if (!progress.moves) {\r\n          progress.moves = [];\r\n        }\r\n\r\n        progress.moves.push({\r\n          time: new Date().getTime(),\r\n          x: inputs[i].current.x,\r\n          y: inputs[i].current.y,\r\n        });\r\n\r\n        if (progress.length > this.maxProgressStack) {\r\n          progress.moves.shift();\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /* move*/\r\n\r\n  /**\r\n   * Determines if the input's history validates a swipe motion.\r\n   * Determines if it did not come to a complete stop (maxRestTime), and if it\r\n   * had enough of a velocity to be considered (ESCAPE_VELOCITY).\r\n   * @param {Array} inputs - The array of Inputs on the screen\r\n   * @return {null|Object} - null if the gesture is not to be emitted,\r\n   *  Object with information otherwise.\r\n   */\r\n  end(inputs) {\r\n    if (this.numInputs === inputs.length) {\r\n      let output = {\r\n        data: [],\r\n      };\r\n\r\n      for (var i = 0; i < inputs.length; i++) {\r\n        // Determine if all input events are on the 'end' event.\r\n        if (inputs[i].current.type !== 'end') {\r\n          return;\r\n        }\r\n\r\n        let progress = inputs[i].getGestureProgress(this.getId());\r\n        if (progress.moves && progress.moves.length > 2) {\r\n          // CHECK : Return if the input has not moved in maxRestTime ms.\r\n\r\n          let currentMove = progress.moves.pop();\r\n          if ((new Date().getTime()) - currentMove.time > this.maxRestTime) {\r\n            return null;\r\n          }\r\n\r\n          let lastMove;\r\n          let index = progress.moves.length - 1;\r\n\r\n          /* Date is unreliable, so we retrieve the last move event where\r\n           the time is not the same. */\r\n          while (index !== -1) {\r\n            if (progress.moves[index].time !== currentMove.time) {\r\n              lastMove = progress.moves[index];\r\n              break;\r\n            }\r\n\r\n            index--;\r\n          }\r\n\r\n          /* If the date is REALLY unreliable, we apply a time distortion\r\n           to the last event.\r\n           */\r\n          if (!lastMove) {\r\n            lastMove = progress.moves.pop();\r\n            lastMove.time += this.timeDistortion;\r\n          }\r\n\r\n          var velocity = util.getVelocity(lastMove.x, lastMove.y, lastMove.time,\r\n            currentMove.x, currentMove.y, currentMove.time);\r\n\r\n          output.data[i] = {\r\n            velocity: velocity,\r\n            distance: util.distanceBetweenTwoPoints(lastMove.x, currentMove.x, lastMove.y, currentMove.y),\r\n            duration:  currentMove.time - lastMove.time,\r\n            currentDirection: util.getAngle(\r\n              lastMove.x,\r\n              lastMove.y,\r\n              currentMove.x,\r\n              currentMove.y),\r\n          };\r\n        }\r\n      }\r\n\r\n      for (var i = 0; i < output.data.length; i++) {\r\n        if (velocity < this.escapeVelocity) {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      if (output.data.length > 0) {\r\n        return output;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /* end*/\r\n}\r\n\r\nexport default Swipe;\r\n","/**\r\n * @file Tap.js\r\n * Contains the Tap class\r\n */\r\n\r\nimport Gesture from './Gesture.js';\r\nimport util from './../core/util.js';\r\n\r\nconst DEFAULT_MIN_DELAY_MS = 0;\r\nconst DEFAULT_MAX_DELAY_MS = 300;\r\nconst DEFAULT_INPUTS = 1;\r\nconst DEFAULT_MOVE_PX_TOLERANCE = 10;\r\n\r\n/**\r\n * A Tap is defined as a touchstart to touchend event in quick succession.\r\n * @class Tap\r\n */\r\nclass Tap extends Gesture {\r\n  /**\r\n   * Constructor function for the Tap class.\r\n   * @param {Object} [options] - The options object.\r\n   * @param {Number} [options.minDelay=0] - The minimum delay between a\r\n   * touchstart and touchend can be configured in milliseconds.\r\n   * @param {Number} [options.maxDelay=300] - The maximum delay between a\r\n   * touchstart and touchend can be configured in milliseconds.\r\n   * @param {Number} [options.numInputs=1] - Number of inputs for Tap gesture.\r\n   * @param {Number} [options.tolerance=10] - The tolerance in pixels\r\n   *  a user can move.\r\n   */\r\n  constructor(options) {\r\n    super();\r\n\r\n    /**\r\n     * The type of the Gesture.\r\n     * @type {String}\r\n     */\r\n    this.type = 'tap';\r\n\r\n    /**\r\n     * The minimum amount between a touchstart and a touchend can be configured\r\n     * in milliseconds. The minimum delay starts to count down when the expected\r\n     * number of inputs are on the screen, and ends when ALL inputs are off the\r\n     * screen.\r\n     * @type {Number}\r\n     */\r\n    this.minDelay = (options && options.minDelay) ?\r\n      options.minDelay : DEFAULT_MIN_DELAY_MS;\r\n\r\n    /**\r\n     * The maximum delay between a touchstart and touchend can be configured in\r\n     * milliseconds. The maximum delay starts to count down when the expected\r\n     * number of inputs are on the screen, and ends when ALL inputs are off the\r\n     * screen.\r\n     * @type {Number}\r\n     */\r\n    this.maxDelay = (options && options.maxDelay) ?\r\n      options.maxDelay : DEFAULT_MAX_DELAY_MS;\r\n\r\n    /**\r\n     * The number of inputs to trigger a Tap can be variable,\r\n     * and the maximum number being a factor of the browser.\r\n     * @type {Number}\r\n     */\r\n    this.numInputs = (options && options.numInputs) ?\r\n      options.numInputs : DEFAULT_INPUTS;\r\n\r\n    /**\r\n     * A move tolerance in pixels allows some slop between a user's start to end\r\n     * events. This allows the Tap gesture to be triggered more easily.\r\n     * @type {number}\r\n     */\r\n    this.tolerance = (options && options.tolerance) ?\r\n      options.tolerance : DEFAULT_MOVE_PX_TOLERANCE;\r\n  }\r\n\r\n  /* constructor*/\r\n\r\n  /**\r\n   * Event hook for the start of a gesture. Keeps track of when the inputs\r\n   * trigger the start event.\r\n   * @param {Array} inputs - The array of Inputs on the screen.\r\n   * @return {null} - Tap does not trigger on a start event.\r\n   */\r\n  start(inputs) {\r\n    if (inputs.length === this.numInputs) {\r\n      inputs.forEach((input) => {\r\n        let progress = input.getGestureProgress(this.getId());\r\n        progress.start = new Date().getTime();\r\n      });\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /* start*/\r\n\r\n  /**\r\n   * Event hook for the move of a gesture. The Tap event reaches here if the\r\n   * user starts to move their input before an 'end' event is reached.\r\n   * @param {Array} inputs - The array of Inputs on the screen.\r\n   * @param {Object} state - The state object of the current region.\r\n   * @param {Element} element - The element associated to the binding.\r\n   * @return {null} - Tap does not trigger on a move event.\r\n   */\r\n  move(inputs, state, element) {\r\n    for (let i = 0; i < inputs.length; i++) {\r\n      if (inputs[i].getCurrentEventType() === 'move') {\r\n        let current = inputs[i].current;\r\n        let previous = inputs[i].previous;\r\n        if (!util.isWithin(\r\n            current.x,\r\n            current.y,\r\n            previous.x,\r\n            previous.y,\r\n            this.tolerance)) {\r\n          let type = this.type;\r\n          inputs.forEach(function(input) {\r\n            input.resetProgress(type);\r\n          });\r\n\r\n          return null;\r\n        }\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /* move*/\r\n\r\n  /**\r\n   * Event hook for the end of a gesture.\r\n   * Determines if this the tap event can be fired if the delay and tolerance\r\n   * constraints are met. Also waits for all of the inputs to be off the screen\r\n   * before determining if the gesture is triggered.\r\n   * @param {Array} inputs - The array of Inputs on the screen.\r\n   * @return {null|Object} - null if the gesture is not to be emitted,\r\n   * Object with information otherwise. Returns the interval time between start\r\n   * and end events.\r\n   */\r\n  end(inputs) {\r\n    if (inputs.length !== this.numInputs) {\r\n      return null;\r\n    }\r\n\r\n    let startTime = Number.MAX_VALUE;\r\n    for (let i = 0; i < inputs.length; i++) {\r\n      if (inputs[i].getCurrentEventType() !== 'end') {\r\n        return null;\r\n      }\r\n\r\n      let progress = inputs[i].getGestureProgress(this.getId());\r\n      if (!progress.start) {\r\n        return null;\r\n      }\r\n\r\n      // Find the most recent input's startTime\r\n      if (progress.start < startTime) {\r\n        startTime = progress.start;\r\n      }\r\n    }\r\n\r\n    let interval = new Date().getTime() - startTime;\r\n    if ((this.minDelay <= interval) && (this.maxDelay >= interval)) {\r\n      return {\r\n        interval: interval,\r\n      };\r\n    } else {\r\n      let type = this.type;\r\n      inputs.forEach(function(input) {\r\n        input.resetProgress(type);\r\n      });\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /* end*/\r\n}\r\n\r\nexport default Tap;\r\n"],"sourceRoot":""}